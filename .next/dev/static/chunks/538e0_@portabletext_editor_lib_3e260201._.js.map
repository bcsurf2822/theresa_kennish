{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.get-block-end-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.get-block-start-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.is-keyed-segment.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.is-equal-paths.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.is-selection-collapsed.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.selection-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.block-offset.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.get-selection-end-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.get-selection-start-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.is-equal-selection-points.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/asserters.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/parse-blocks.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/key-generator.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.slice-blocks.ts"],"sourcesContent":["import {isSpan, isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport function getBlockEndPoint({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: {\n    node: PortableTextBlock\n    path: BlockPath\n  }\n}): EditorSelectionPoint {\n  if (isTextBlock(context, block.node)) {\n    const lastChild = block.node.children[block.node.children.length - 1]\n\n    if (lastChild) {\n      return {\n        path: [...block.path, 'children', {_key: lastChild._key}],\n        offset: isSpan(context, lastChild) ? lastChild.text.length : 0,\n      }\n    }\n  }\n\n  return {\n    path: block.path,\n    offset: 0,\n  }\n}\n","import {isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport function getBlockStartPoint({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: {\n    node: PortableTextBlock\n    path: BlockPath\n  }\n}): EditorSelectionPoint {\n  if (isTextBlock(context, block.node)) {\n    return {\n      path: [...block.path, 'children', {_key: block.node.children[0]._key}],\n      offset: 0,\n    }\n  }\n\n  return {\n    path: block.path,\n    offset: 0,\n  }\n}\n","import type {KeyedSegment} from '../types/paths'\n\n/**\n * @public\n */\nexport function isKeyedSegment(segment: unknown): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n","import type {Path} from '../types/paths'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\nexport function isEqualPaths(a: Path, b: Path): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    const segA = a.at(i)\n    const segB = b.at(i)\n\n    if (\n      (typeof segA === 'string' || typeof segA === 'number') &&\n      (typeof segB === 'string' || typeof segB === 'number')\n    ) {\n      if (segA !== segB) {\n        return false\n      }\n\n      continue\n    }\n\n    if (isKeyedSegment(segA) && isKeyedSegment(segB)) {\n      if (segA._key !== segB._key) {\n        return false\n      }\n\n      continue\n    }\n\n    if (Array.isArray(segA) && Array.isArray(segB)) {\n      if (segA.at(0) !== segB.at(0) || segA.at(1) !== segB.at(1)) {\n        return false\n      }\n\n      continue\n    }\n\n    return false\n  }\n\n  return true\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualPaths} from './util.is-equal-paths'\n\n/**\n * @public\n */\nexport function isSelectionCollapsed(selection: EditorSelection) {\n  if (!selection) {\n    return false\n  }\n\n  return (\n    isEqualPaths(selection.anchor.path, selection.focus.path) &&\n    selection.anchor.offset === selection.focus.offset\n  )\n}\n","import type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\nexport function getBlockKeyFromSelectionPoint(point: EditorSelectionPoint) {\n  const blockPathSegment = point.path.at(0)\n\n  if (isKeyedSegment(blockPathSegment)) {\n    return blockPathSegment._key\n  }\n\n  return undefined\n}\n\nexport function getChildKeyFromSelectionPoint(point: EditorSelectionPoint) {\n  const childPathSegment = point.path.at(2)\n\n  if (isKeyedSegment(childPathSegment)) {\n    return childPathSegment._key\n  }\n\n  return undefined\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {ChildPath} from '../types/paths'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  context,\n  blockOffset,\n  direction,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint: {path: ChildPath; offset: number} | undefined\n  let skippedInlineObject = false\n\n  for (const block of context.value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (direction === 'forward') {\n        if (!isSpan(context, child)) {\n          continue\n        }\n\n        if (offsetLeft <= child.text.length) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: offsetLeft,\n          }\n          break\n        }\n\n        offsetLeft -= child.text.length\n\n        continue\n      }\n\n      if (!isSpan(context, child)) {\n        skippedInlineObject = true\n        continue\n      }\n\n      if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n        if (skippedInlineObject) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: 0,\n          }\n        }\n        break\n      }\n\n      if (offsetLeft > child.text.length) {\n        offsetLeft -= child.text.length\n        continue\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n\n        offsetLeft -= child.text.length\n\n        if (offsetLeft !== 0) {\n          break\n        }\n      }\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n  const spanKey = getChildKeyFromSelectionPoint(selectionPoint)\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of context.value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isSpan(context, child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n}\n","import type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getSelectionEndPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends EditorSelectionPoint | null =\n    TEditorSelection extends NonNullable<EditorSelection>\n      ? EditorSelectionPoint\n      : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.anchor : selection.focus\n  ) as TEditorSelectionPoint\n}\n","import type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getSelectionStartPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends EditorSelectionPoint | null =\n    TEditorSelection extends NonNullable<EditorSelection>\n      ? EditorSelectionPoint\n      : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.focus : selection.anchor\n  ) as TEditorSelectionPoint\n}\n","import type {EditorSelectionPoint} from '../types/editor'\nimport {isEqualPaths} from './util.is-equal-paths'\n\n/**\n * @public\n */\nexport function isEqualSelectionPoints(\n  a: EditorSelectionPoint,\n  b: EditorSelectionPoint,\n) {\n  return a.offset === b.offset && isEqualPaths(a.path, b.path)\n}\n","import type {TypedObject} from '@portabletext/schema'\n\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n","import {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n  type TypedObject,\n} from '@portabletext/schema'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isRecord, isTypedObject} from './asserters'\n\nexport function parseBlocks({\n  context,\n  blocks,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  blocks: unknown\n  options: {\n    normalize: boolean\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): Array<PortableTextBlock> {\n  if (!Array.isArray(blocks)) {\n    return []\n  }\n\n  return blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({context, block, options})\n\n    return parsedBlock ? [parsedBlock] : []\n  })\n}\n\nexport function parseBlock({\n  context,\n  block,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  block: unknown\n  options: {\n    normalize: boolean\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): PortableTextBlock | undefined {\n  return (\n    parseTextBlock({block, context, options}) ??\n    parseBlockObject({blockObject: block, context, options})\n  )\n}\n\nexport function parseBlockObject({\n  blockObject,\n  context,\n  options,\n}: {\n  blockObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(blockObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.blockObjects.find(\n    ({name}) => name === blockObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: blockObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function isListBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: unknown,\n): block is PortableTextListBlock {\n  return (\n    isTextBlock(context, block) &&\n    block.level !== undefined &&\n    block.listItem !== undefined\n  )\n}\n\nexport function parseTextBlock({\n  block,\n  context,\n  options,\n}: {\n  block: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {\n    normalize: boolean\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): PortableTextTextBlock | undefined {\n  if (!isTypedObject(block)) {\n    return undefined\n  }\n\n  const customFields: Record<string, unknown> = {}\n\n  for (const key of Object.keys(block)) {\n    if (\n      key === '_type' ||\n      key === '_key' ||\n      key === 'children' ||\n      key === 'markDefs' ||\n      key === 'style' ||\n      key === 'listItem' ||\n      key === 'level'\n    ) {\n      continue\n    }\n\n    if (options.validateFields) {\n      if (context.schema.block.fields?.some((field) => field.name === key)) {\n        customFields[key] = block[key]\n      }\n    } else {\n      customFields[key] = block[key]\n    }\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return undefined\n  }\n\n  const _key =\n    typeof block._key === 'string' ? block._key : context.keyGenerator()\n\n  const {markDefs, markDefKeyMap} = parseMarkDefs({\n    context,\n    markDefs: block.markDefs,\n    options,\n  })\n\n  const unparsedChildren: Array<unknown> = Array.isArray(block.children)\n    ? block.children\n    : []\n\n  const parsedChildren = unparsedChildren\n    .map((child) => parseChild({child, context, markDefKeyMap, options}))\n    .filter((child) => child !== undefined)\n  const marks = parsedChildren.flatMap((child) => child.marks ?? [])\n\n  const children =\n    parsedChildren.length > 0\n      ? parsedChildren\n      : [\n          {\n            _key: context.keyGenerator(),\n            _type: context.schema.span.name,\n            text: '',\n            marks: [],\n          },\n        ]\n\n  const normalizedChildren = options.normalize\n    ? // Ensure that inline objects re surrounded by spans\n      children.reduce<Array<PortableTextObject | PortableTextSpan>>(\n        (normalizedChildren, child, index) => {\n          if (isSpan(context, child)) {\n            return [...normalizedChildren, child]\n          }\n\n          const previousChild = normalizedChildren.at(-1)\n\n          if (!previousChild || !isSpan(context, previousChild)) {\n            return [\n              ...normalizedChildren,\n              {\n                _key: context.keyGenerator(),\n                _type: context.schema.span.name,\n                text: '',\n                marks: [],\n              },\n              child,\n              ...(index === children.length - 1\n                ? [\n                    {\n                      _key: context.keyGenerator(),\n                      _type: context.schema.span.name,\n                      text: '',\n                      marks: [],\n                    },\n                  ]\n                : []),\n            ]\n          }\n\n          return [...normalizedChildren, child]\n        },\n        [],\n      )\n    : children\n\n  const parsedBlock: PortableTextTextBlock = {\n    _type: context.schema.block.name,\n    _key,\n    children: normalizedChildren,\n    ...customFields,\n  }\n\n  if (typeof block.markDefs === 'object' && block.markDefs !== null) {\n    parsedBlock.markDefs = options.removeUnusedMarkDefs\n      ? markDefs.filter((markDef) => marks.includes(markDef._key))\n      : markDefs\n  }\n\n  if (\n    typeof block.style === 'string' &&\n    context.schema.styles.find((style) => style.name === block.style)\n  ) {\n    parsedBlock.style = block.style\n  }\n\n  if (\n    typeof block.listItem === 'string' &&\n    context.schema.lists.find((list) => list.name === block.listItem)\n  ) {\n    parsedBlock.listItem = block.listItem\n  }\n\n  if (typeof block.level === 'number') {\n    parsedBlock.level = block.level\n  }\n\n  return parsedBlock\n}\n\nexport function parseMarkDefs({\n  context,\n  markDefs,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefs: unknown\n  options: {validateFields: boolean}\n}): {\n  markDefs: Array<PortableTextObject>\n  markDefKeyMap: Map<string, string>\n} {\n  const unparsedMarkDefs: Array<unknown> = Array.isArray(markDefs)\n    ? markDefs\n    : []\n  const markDefKeyMap = new Map<string, string>()\n\n  const parsedMarkDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef)) {\n      return []\n    }\n\n    const schemaType = context.schema.annotations.find(\n      ({name}) => name === markDef._type,\n    )\n\n    if (!schemaType) {\n      return []\n    }\n\n    if (typeof markDef._key !== 'string') {\n      // If the `markDef` doesn't have a `_key` then we don't know what spans\n      // it belongs to and therefore we have to discard it.\n      return []\n    }\n\n    const parsedAnnotation = parseObject({\n      object: markDef,\n      context: {\n        schemaType,\n        keyGenerator: context.keyGenerator,\n      },\n      options,\n    })\n\n    if (!parsedAnnotation) {\n      return []\n    }\n\n    markDefKeyMap.set(markDef._key, parsedAnnotation._key)\n\n    return [parsedAnnotation]\n  })\n\n  return {\n    markDefs: parsedMarkDefs,\n    markDefKeyMap,\n  }\n}\n\nexport function parseChild({\n  child,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  child: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {validateFields: boolean}\n}): PortableTextSpan | PortableTextObject | undefined {\n  return (\n    parseSpan({span: child, context, markDefKeyMap, options}) ??\n    parseInlineObject({inlineObject: child, context, options})\n  )\n}\n\nexport function parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  span: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {validateFields: boolean}\n}): PortableTextSpan | undefined {\n  if (!isRecord(span)) {\n    return undefined\n  }\n\n  const customFields: Record<string, unknown> = {}\n\n  for (const key of Object.keys(span)) {\n    if (\n      key !== '_type' &&\n      key !== '_key' &&\n      key !== 'text' &&\n      key !== 'marks'\n    ) {\n      customFields[key] = span[key]\n    }\n  }\n\n  const unparsedMarks: Array<unknown> = Array.isArray(span.marks)\n    ? span.marks\n    : []\n  const marks = unparsedMarks.flatMap((mark) => {\n    if (typeof mark !== 'string') {\n      return []\n    }\n\n    const markDefKey = markDefKeyMap.get(mark)\n\n    if (markDefKey !== undefined) {\n      return [markDefKey]\n    }\n\n    if (\n      context.schema.decorators.some((decorator) => decorator.name === mark)\n    ) {\n      return [mark]\n    }\n\n    return []\n  })\n\n  if (\n    typeof span._type === 'string' &&\n    span._type !== context.schema.span.name\n  ) {\n    return undefined\n  }\n\n  if (typeof span._type !== 'string') {\n    if (typeof span.text === 'string') {\n      return {\n        _type: context.schema.span.name as 'span',\n        _key:\n          typeof span._key === 'string' ? span._key : context.keyGenerator(),\n        text: span.text,\n        marks,\n        ...(options.validateFields ? {} : customFields),\n      }\n    }\n\n    return undefined\n  }\n\n  return {\n    _type: context.schema.span.name as 'span',\n    _key: typeof span._key === 'string' ? span._key : context.keyGenerator(),\n    text: typeof span.text === 'string' ? span.text : '',\n    marks,\n    ...(options.validateFields ? {} : customFields),\n  }\n}\n\nexport function parseInlineObject({\n  inlineObject,\n  context,\n  options,\n}: {\n  inlineObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(inlineObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.inlineObjects.find(\n    ({name}) => name === inlineObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: inlineObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function parseAnnotation({\n  annotation,\n  context,\n  options,\n}: {\n  annotation: TypedObject\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(annotation)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.annotations.find(\n    ({name}) => name === annotation._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: annotation,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nfunction parseObject({\n  object,\n  context,\n  options,\n}: {\n  object: TypedObject\n  context: Pick<EditorContext, 'keyGenerator'> & {\n    schemaType: EditorSchema['blockObjects'][0]\n  }\n  options: {validateFields: boolean}\n}): PortableTextObject {\n  const {_type, _key, ...customFields} = object\n\n  // Validates all props on the object and only takes those that match\n  // the name of a field\n  const values = options.validateFields\n    ? context.schemaType.fields.reduce<Record<string, unknown>>(\n        (fieldValues, field) => {\n          const fieldValue = object[field.name]\n\n          if (fieldValue !== undefined) {\n            fieldValues[field.name] = fieldValue\n          }\n\n          return fieldValues\n        },\n        {},\n      )\n    : customFields\n\n  return {\n    _type: context.schemaType.name,\n    _key:\n      typeof object._key === 'string' ? object._key : context.keyGenerator(),\n    ...values,\n  }\n}\n","/**\n * @public\n */\nexport const defaultKeyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import {isSpan, isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {defaultKeyGenerator} from './key-generator'\nimport {parseBlock} from './parse-blocks'\nimport {getSelectionEndPoint} from './util.get-selection-end-point'\nimport {getSelectionStartPoint} from './util.get-selection-start-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * @public\n */\nexport function sliceBlocks({\n  context,\n  blocks,\n}: {\n  context: Pick<EditorContext, 'schema' | 'selection'> & {\n    keyGenerator?: () => string\n  }\n  blocks: Array<PortableTextBlock>\n}): Array<PortableTextBlock> {\n  const slice: Array<PortableTextBlock> = []\n\n  if (!context.selection) {\n    return slice\n  }\n\n  let startBlock: PortableTextBlock | undefined\n  const middleBlocks: PortableTextBlock[] = []\n  let endBlock: PortableTextBlock | undefined\n\n  const startPoint = getSelectionStartPoint(context.selection)\n  const endPoint = getSelectionEndPoint(context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return slice\n  }\n\n  for (const block of blocks) {\n    if (!isTextBlock(context, block)) {\n      if (block._key === startBlockKey && block._key === endBlockKey) {\n        startBlock = block\n        break\n      }\n    }\n\n    if (block._key === startBlockKey) {\n      if (!isTextBlock(context, block)) {\n        startBlock = block\n        continue\n      }\n\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if (isSpan(context, child)) {\n              const text =\n                child._key === endChildKey\n                  ? child.text.slice(startPoint.offset, endPoint.offset)\n                  : child.text.slice(startPoint.offset)\n\n              startBlock = {\n                ...block,\n                children: [\n                  {\n                    ...child,\n                    text,\n                  },\n                ],\n              }\n            } else {\n              startBlock = {\n                ...block,\n                children: [child],\n              }\n            }\n\n            if (block._key === endBlockKey && startChildKey === endChildKey) {\n              break\n            }\n            continue\n          }\n\n          if (startBlock && isTextBlock(context, startBlock)) {\n            if (\n              endChildKey &&\n              child._key === endChildKey &&\n              isSpan(context, child)\n            ) {\n              startBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n            } else {\n              startBlock.children.push(child)\n            }\n\n            if (\n              block._key === endBlockKey &&\n              endChildKey &&\n              child._key === endChildKey\n            ) {\n              break\n            }\n          }\n        }\n\n        if (startBlockKey === endBlockKey) {\n          break\n        }\n\n        continue\n      }\n\n      startBlock = block\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n    }\n\n    if (block._key === endBlockKey) {\n      if (!isTextBlock(context, block)) {\n        endBlock = block\n        break\n      }\n\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: [],\n        }\n\n        for (const child of block.children) {\n          if (endBlock && isTextBlock(context, endBlock)) {\n            if (child._key === endChildKey && isSpan(context, child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n\n              break\n            }\n\n            endBlock.children.push(child)\n\n            if (endChildKey && child._key === endChildKey) {\n              break\n            }\n          }\n        }\n\n        break\n      }\n\n      endBlock = block\n\n      break\n    }\n\n    if (startBlock) {\n      middleBlocks.push(\n        parseBlock({\n          context: {\n            schema: context.schema,\n            keyGenerator: context.keyGenerator ?? defaultKeyGenerator,\n          },\n          block,\n          options: {\n            normalize: false,\n            removeUnusedMarkDefs: true,\n            validateFields: false,\n          },\n        }) ?? block,\n      )\n    }\n  }\n\n  const parsedStartBlock = startBlock\n    ? parseBlock({\n        context: {\n          schema: context.schema,\n          keyGenerator: context.keyGenerator ?? defaultKeyGenerator,\n        },\n        block: startBlock,\n        options: {\n          normalize: false,\n          removeUnusedMarkDefs: true,\n          validateFields: false,\n        },\n      })\n    : undefined\n\n  const parsedEndBlock = endBlock\n    ? parseBlock({\n        context: {\n          schema: context.schema,\n          keyGenerator: context.keyGenerator ?? defaultKeyGenerator,\n        },\n        block: endBlock,\n        options: {\n          normalize: false,\n          removeUnusedMarkDefs: true,\n          validateFields: false,\n        },\n      })\n    : undefined\n\n  return [\n    ...(parsedStartBlock ? [parsedStartBlock] : []),\n    ...middleBlocks,\n    ...(parsedEndBlock ? [parsedEndBlock] : []),\n  ]\n}\n"],"names":["getBlockEndPoint","context","block","isTextBlock","node","lastChild","children","length","path","_key","offset","isSpan","text","getBlockStartPoint","isKeyedSegment","segment","isEqualPaths","a","b","i","segA","at","segB","Array","isArray","isSelectionCollapsed","selection","anchor","focus","getBlockKeyFromSelectionPoint","point","blockPathSegment","getChildKeyFromSelectionPoint","childPathSegment","blockOffsetToSpanSelectionPoint","blockOffset","direction","offsetLeft","selectionPoint","skippedInlineObject","value","child","spanSelectionPointToBlockOffset","blockKey","spanKey","getSelectionEndPoint","backward","getSelectionStartPoint","isEqualSelectionPoints","isTypedObject","object","isRecord","_type","parseBlocks","blocks","options","flatMap","parsedBlock","parseBlock","parseTextBlock","parseBlockObject","blockObject","schemaType","schema","blockObjects","find","name","parseObject","keyGenerator","isListBlock","level","undefined","listItem","customFields","key","Object","keys","validateFields","fields","some","field","markDefs","markDefKeyMap","parseMarkDefs","parsedChildren","map","parseChild","filter","marks","span","normalizedChildren","normalize","reduce","index","previousChild","removeUnusedMarkDefs","markDef","includes","style","styles","lists","list","unparsedMarkDefs","Map","annotations","parsedAnnotation","set","parseSpan","parseInlineObject","inlineObject","mark","markDefKey","get","decorators","decorator","inlineObjects","parseAnnotation","annotation","values","fieldValues","fieldValue","defaultKeyGenerator","randomKey","getByteHexTable","table","toString","slice","whatwgRNG","rnds8","Uint8Array","crypto","getRandomValues","str","n","sliceBlocks","startBlock","middleBlocks","endBlock","startPoint","endPoint","startBlockKey","startChildKey","endBlockKey","endChildKey","push","parsedStartBlock","parsedEndBlock"],"mappings":"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","debugId":null}},
    {"offset": {"line": 546, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-text-block.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.get-text-block-text.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.is-empty-text-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.slice-text-block.ts"],"sourcesContent":["import type {PortableTextTextBlock} from '@portabletext/schema'\n\n/**\n * @public\n */\nexport function getTextBlockText(block: PortableTextTextBlock) {\n  return block.children.map((child) => child.text ?? '').join('')\n}\n","import {isSpan, isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {getTextBlockText} from './util.get-text-block-text'\n\n/**\n * @public\n */\nexport function isEmptyTextBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: PortableTextBlock | unknown,\n) {\n  if (!isTextBlock(context, block)) {\n    return false\n  }\n\n  const onlyText = block.children.every((child) => isSpan(context, child))\n  const blockText = getTextBlockText(block)\n\n  return onlyText && blockText === ''\n}\n","import {\n  isSpan,\n  type PortableTextChild,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {getSelectionEndPoint} from './util.get-selection-end-point'\nimport {getSelectionStartPoint} from './util.get-selection-start-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\nexport function sliceTextBlock({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema' | 'selection'>\n  block: PortableTextTextBlock\n}): PortableTextTextBlock {\n  const startPoint = getSelectionStartPoint(context.selection)\n  const endPoint = getSelectionEndPoint(context.selection)\n\n  if (!startPoint || !endPoint) {\n    return block\n  }\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (startBlockKey !== endBlockKey || startBlockKey !== block._key) {\n    return block\n  }\n\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startChildKey || !endChildKey) {\n    return block\n  }\n\n  let startChildFound = false\n  const children: Array<PortableTextChild> = []\n\n  for (const child of block.children) {\n    if (child._key === startChildKey) {\n      startChildFound = true\n\n      if (isSpan(context, child)) {\n        const text =\n          child._key === endChildKey\n            ? child.text.slice(startPoint.offset, endPoint.offset)\n            : child.text.slice(startPoint.offset)\n\n        children.push({\n          ...child,\n          text,\n        })\n      } else {\n        children.push(child)\n      }\n\n      if (startChildKey === endChildKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (child._key === endChildKey) {\n      if (isSpan(context, child)) {\n        children.push({\n          ...child,\n          text: child.text.slice(0, endPoint.offset),\n        })\n      } else {\n        children.push(child)\n      }\n\n      break\n    }\n\n    if (startChildFound) {\n      children.push(child)\n    }\n  }\n\n  return {\n    ...block,\n    children,\n  }\n}\n"],"names":["getTextBlockText","block","children","map","child","text","join","isEmptyTextBlock","context","isTextBlock","onlyText","every","isSpan","blockText","sliceTextBlock","startPoint","getSelectionStartPoint","selection","endPoint","getSelectionEndPoint","startBlockKey","getBlockKeyFromSelectionPoint","endBlockKey","_key","startChildKey","getChildKeyFromSelectionPoint","endChildKey","startChildFound","slice","offset","push"],"mappings":";;;;;;;;;;;;AAKO,SAASA,iBAAiBC,KAAAA,EAA8B;IAC7D,OAAOA,MAAMC,QAAAA,CAASC,GAAAA,CAAKC,CAAAA,QAAUA,MAAMC,IAAAA,IAAQ,EAAE,EAAEC,IAAAA,CAAK,EAAE;AAChE;ACAO,SAASC,iBACdC,OAAAA,EACAP,KAAAA,EACA;IACA,IAAI,KAACQ,wRAAAA,EAAYD,SAASP,KAAK,GAC7B,OAAO,CAAA;IAGT,MAAMS,WAAWT,MAAMC,QAAAA,CAASS,KAAAA,CAAOP,CAAAA,YAAUQ,mRAAAA,EAAOJ,SAASJ,KAAK,CAAC,GACjES,YAAYb,iBAAiBC,KAAK;IAExC,OAAOS,YAAYG,cAAc;AACnC;ACNO,SAASC,eAAe,EAC7BN,OAAAA,EACAP,KAAAA,EAIF,EAA0B;IACxB,MAAMc,iBAAaC,wcAAAA,EAAuBR,QAAQS,SAAS,GACrDC,eAAWC,scAAAA,EAAqBX,QAAQS,SAAS;IAEvD,IAAI,CAACF,cAAc,CAACG,UAClB,OAAOjB;IAGT,MAAMmB,oBAAgBC,+cAAAA,EAA8BN,UAAU,GACxDO,kBAAcD,+cAAAA,EAA8BH,QAAQ;IAE1D,IAAIE,kBAAkBE,eAAeF,kBAAkBnB,MAAMsB,IAAAA,EAC3D,OAAOtB;IAGT,MAAMuB,oBAAgBC,+cAAAA,EAA8BV,UAAU,GACxDW,kBAAcD,+cAAAA,EAA8BP,QAAQ;IAE1D,IAAI,CAACM,iBAAiB,CAACE,aACrB,OAAOzB;IAGT,IAAI0B,kBAAkB,CAAA;IACtB,MAAMzB,WAAqC,CAAA,CAAA;IAE3C,KAAA,MAAWE,SAASH,MAAMC,QAAAA,CAAU;QAClC,IAAIE,MAAMmB,IAAAA,KAASC,eAAe;YAGhC,IAFAG,kBAAkB,CAAA,OAEdf,mRAAAA,EAAOJ,SAASJ,KAAK,GAAG;gBAC1B,MAAMC,OACJD,MAAMmB,IAAAA,KAASG,cACXtB,MAAMC,IAAAA,CAAKuB,KAAAA,CAAMb,WAAWc,MAAAA,EAAQX,SAASW,MAAM,IACnDzB,MAAMC,IAAAA,CAAKuB,KAAAA,CAAMb,WAAWc,MAAM;gBAExC3B,SAAS4B,IAAAA,CAAK;oBACZ,GAAG1B,KAAAA;oBACHC;gBAAAA,CACD;YACH,OACEH,SAAS4B,IAAAA,CAAK1B,KAAK;YAGrB,IAAIoB,kBAAkBE,aACpB;YAGF;QACF;QAEA,IAAItB,MAAMmB,IAAAA,KAASG,aAAa;YAC1Bd,IAAAA,mRAAAA,EAAOJ,SAASJ,KAAK,IACvBF,SAAS4B,IAAAA,CAAK;gBACZ,GAAG1B,KAAAA;gBACHC,MAAMD,MAAMC,IAAAA,CAAKuB,KAAAA,CAAM,GAAGV,SAASW,MAAM;YAAA,CAC1C,IAED3B,SAAS4B,IAAAA,CAAK1B,KAAK;YAGrB;QACF;QAEIuB,mBACFzB,SAAS4B,IAAAA,CAAK1B,KAAK;IAEvB;IAEA,OAAO;QACL,GAAGH,KAAAA;QACHC;IAAAA;AAEJ","debugId":null}},
    {"offset": {"line": 607, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selecting-entire-blocks.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/types/paths.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.is-selection-expanded.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-focus-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-focus-text-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-focus-child.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-focus-span.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-end-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-end-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-next-span.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-start-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-start-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-previous-span.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selected-children.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selected-spans.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-mark-state.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selected-blocks.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-active-annotations.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-active-list-item.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-active-style.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-next-inline-object.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-previous-inline-object.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selected-value.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-text.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-selection-collapsed.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-selection-expanded.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-caret-word-selection.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-focus-block-object.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-focus-inline-object.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-focus-list-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-last-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-next-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-previous-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selected-text-blocks.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-end-child.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection-start-child.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-active-annotation-marks.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-active-annotation.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-active-decorators.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-active-decorator.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-active-list-item.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-active-style.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-at-the-end-of-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-at-the-start-of-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.compare-points.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-overlapping-selection.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-selecting-entire-blocks.ts"],"sourcesContent":["/**\n * A segment in a path that identifies an element by its `_key` property.\n * @public\n */\nexport interface KeyedSegment {\n  _key: string\n}\n\n/**\n * A tuple representing a range selection, e.g., `[0, 5]` or `['', 3]`.\n * @public\n */\nexport type IndexTuple = [number | '', number | '']\n\n/**\n * A single segment in a path. Can be:\n * - A string (property name)\n * - A number (array index)\n * - A KeyedSegment (object with `_key`)\n * - An IndexTuple (range selection)\n * @public\n */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/**\n * A path is an array of path segments that describes a location in a document.\n * @public\n */\nexport type Path = PathSegment[]\n\n/**\n * @public\n */\nexport type BlockPath = [{_key: string}]\n\n/**\n * @public\n */\nexport function isBlockPath(path: Path): path is BlockPath {\n  const firstSegment = path.at(0)\n\n  return (\n    path.length === 1 &&\n    firstSegment !== undefined &&\n    isRecord(firstSegment) &&\n    '_key' in firstSegment &&\n    typeof firstSegment._key === 'string'\n  )\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type AnnotationPath = [{_key: string}, 'markDefs', {_key: string}]\n\n/**\n * @public\n */\nexport type ChildPath = [{_key: string}, 'children', {_key: string}]\n","import type {EditorSelection} from '../types/editor'\nimport {isSelectionCollapsed} from './util.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isSelectionExpanded(selection: EditorSelection) {\n  if (!selection) {\n    return false\n  }\n\n  return !isSelectionCollapsed(selection)\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = getBlockKeyFromSelectionPoint(snapshot.context.selection.focus)\n  const index = key ? snapshot.blockIndexMap.get(key) : undefined\n\n  const node =\n    index !== undefined ? snapshot.context.value.at(index) : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const focusBlock = getFocusTextBlock(snapshot)\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = getChildKeyFromSelectionPoint(snapshot.context.selection.focus)\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import {isSpan, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  {node: PortableTextSpan; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import {isSpan, isTextBlock, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {KeyedSegment} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionEndBlock || !selectionEndPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionEndBlock.node)) {\n    return undefined\n  }\n\n  const selectionEndPointChildKey =\n    getChildKeyFromSelectionPoint(selectionEndPoint)\n\n  let endPointChildFound = false\n  let nextSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionEndBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (isSpan(snapshot.context, child) && endPointChildFound) {\n      nextSpan = {\n        node: child,\n        path: [...selectionEndBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return nextSpan\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n}\n","import {isSpan, isTextBlock, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {KeyedSegment} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n\n  if (!selectionStartBlock || !selectionStartPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionStartBlock.node)) {\n    return undefined\n  }\n\n  const selectionStartPointChildKey =\n    getChildKeyFromSelectionPoint(selectionStartPoint)\n\n  let previousSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionStartBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (isSpan(snapshot.context, child)) {\n      previousSpan = {\n        node: child,\n        path: [...selectionStartBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return previousSpan\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {PortableTextChild} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\ntype SelectedChild<TChild extends PortableTextChild = PortableTextChild> = {\n  node: TChild\n  path: ChildPath\n}\n\ntype GetSelectedChildrenOptions<\n  TChild extends PortableTextChild = PortableTextChild,\n> = {\n  filter?: (child: PortableTextChild) => child is TChild\n}\n\nexport function getSelectedChildren<\n  TChild extends PortableTextChild = PortableTextChild,\n>(\n  options?: GetSelectedChildrenOptions<TChild>,\n): EditorSelector<Array<SelectedChild<TChild>>> {\n  const filter = options?.filter\n\n  return (snapshot) => {\n    const startPoint = getSelectionStartPoint(snapshot)\n    const endPoint = getSelectionEndPoint(snapshot)\n\n    if (!startPoint || !endPoint) {\n      return []\n    }\n\n    const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n    const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n    const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n    const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n    if (!startBlockKey || !endBlockKey) {\n      return []\n    }\n\n    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n    const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n    if (startBlockIndex === undefined || endBlockIndex === undefined) {\n      return []\n    }\n\n    const selectedChildren: Array<SelectedChild<TChild>> = []\n    const minBlockIndex = Math.min(startBlockIndex, endBlockIndex)\n    const maxBlockIndex = Math.max(startBlockIndex, endBlockIndex)\n    const blocks = snapshot.context.value.slice(\n      minBlockIndex,\n      maxBlockIndex + 1,\n    )\n\n    let startChildFound = false\n\n    for (const block of blocks) {\n      if (!isTextBlock(snapshot.context, block)) {\n        continue\n      }\n\n      const isStartBlock = block._key === startBlockKey\n      const isEndBlock = block._key === endBlockKey\n      const isMiddleBlock = !isStartBlock && !isEndBlock\n\n      for (const child of block.children) {\n        const isStartChild = child._key === startChildKey\n        const isEndChild = child._key === endChildKey\n\n        const addChild = () => {\n          if (!filter || filter(child)) {\n            selectedChildren.push({\n              node: child as TChild,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n        }\n\n        if (isMiddleBlock) {\n          addChild()\n          continue\n        }\n\n        if (isStartChild) {\n          startChildFound = true\n          if (isSpan(snapshot.context, child)) {\n            if (startPoint.offset < child.text.length) {\n              addChild()\n            }\n          } else {\n            addChild()\n          }\n\n          if (startChildKey === endChildKey) {\n            break\n          }\n          continue\n        }\n\n        if (isEndChild) {\n          if (isSpan(snapshot.context, child)) {\n            if (endPoint.offset > 0) {\n              addChild()\n            }\n          } else {\n            addChild()\n          }\n          break\n        }\n\n        if (startChildFound) {\n          addChild()\n        }\n      }\n\n      if (isStartBlock && startBlockKey === endBlockKey) {\n        break\n      }\n\n      if (isStartBlock) {\n        startChildFound = true\n      }\n    }\n\n    return selectedChildren\n  }\n}\n","import {isSpan, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectedChildren} from './selector.get-selected-children'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  return getSelectedChildren({\n    filter: (child) => isSpan(snapshot.context, child),\n  })(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isBlockPath} from '../types/paths'\nimport {blockOffsetToSpanSelectionPoint} from '../utils/util.block-offset'\nimport {isSelectionExpanded} from '../utils/util.is-selection-expanded'\nimport {getFocusSpan} from './selector.get-focus-span'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextSpan} from './selector.get-next-span'\nimport {getPreviousSpan} from './selector.get-previous-span'\nimport {getSelectedSpans} from './selector.get-selected-spans'\n\n/**\n * @beta\n */\nexport type MarkState =\n  | {\n      state: 'unchanged'\n      marks: Array<string>\n    }\n  | {\n      state: 'changed'\n      marks: Array<string>\n      previousMarks: Array<string>\n    }\n\n/**\n * Given that text is inserted at the current position, what marks should\n * be applied?\n * @beta\n */\nexport const getMarkState: EditorSelector<MarkState | undefined> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  let selection = snapshot.context.selection\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  if (!focusTextBlock) {\n    return undefined\n  }\n\n  if (isBlockPath(selection.anchor.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.anchor.path,\n        offset: selection.anchor.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          anchor: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  if (isBlockPath(selection.focus.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.focus.path,\n        offset: selection.focus.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          focus: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  const focusSpan = getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n\n  if (!focusSpan) {\n    return undefined\n  }\n\n  if (isSelectionExpanded(selection)) {\n    const selectedSpans = getSelectedSpans({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    let index = 0\n    let marks: Array<string> = []\n\n    for (const span of selectedSpans) {\n      if (index === 0) {\n        marks = span.node.marks ?? []\n      } else {\n        if (span.node.marks?.length === 0) {\n          marks = []\n          continue\n        }\n\n        marks = marks.filter((mark) =>\n          (span.node.marks ?? []).some((spanMark) => spanMark === mark),\n        )\n      }\n\n      index++\n    }\n\n    return {\n      state: 'unchanged',\n      marks,\n    }\n  }\n\n  const decorators = snapshot.context.schema.decorators.map(\n    (decorator) => decorator.name,\n  )\n  const marks = focusSpan.node.marks ?? []\n  const marksWithoutAnnotations = marks.filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  const spanHasAnnotations = marks.length > marksWithoutAnnotations.length\n\n  const spanIsEmpty = focusSpan.node.text.length === 0\n\n  const atTheBeginningOfSpan = snapshot.context.selection.anchor.offset === 0\n  const atTheEndOfSpan =\n    snapshot.context.selection.anchor.offset === focusSpan.node.text.length\n\n  const previousSpan = getPreviousSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpan = getNextSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpanAnnotations =\n    nextSpan?.node?.marks?.filter((mark) => !decorators.includes(mark)) ?? []\n  const spanAnnotations = marks.filter((mark) => !decorators.includes(mark))\n\n  const previousSpanHasAnnotations = previousSpan\n    ? previousSpan.node.marks?.some((mark) => !decorators.includes(mark))\n    : false\n  const previousSpanHasSameAnnotations = previousSpan\n    ? previousSpan.node.marks\n        ?.filter((mark) => !decorators.includes(mark))\n        .every((mark) => marks.includes(mark))\n    : false\n  const previousSpanHasSameAnnotation = previousSpan\n    ? previousSpan.node.marks?.some(\n        (mark) => !decorators.includes(mark) && marks.includes(mark),\n      )\n    : false\n\n  const previousSpanHasSameMarks = previousSpan\n    ? previousSpan.node.marks?.every((mark) => marks.includes(mark))\n    : false\n  const nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) =>\n    nextSpanAnnotations?.includes(mark),\n  )\n\n  if (spanHasAnnotations && !spanIsEmpty) {\n    if (atTheBeginningOfSpan) {\n      if (previousSpanHasSameMarks) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotations) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotation) {\n        return {\n          state: 'unchanged',\n          marks: focusSpan.node.marks ?? [],\n        }\n      } else if (!previousSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n    }\n\n    if (atTheEndOfSpan) {\n      if (!nextSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n\n      if (nextSpanAnnotations.length > 0 && !nextSpanSharesSomeAnnotations) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n\n      if (\n        (nextSpanSharesSomeAnnotations &&\n          nextSpanAnnotations.length < spanAnnotations.length) ||\n        !nextSpanSharesSomeAnnotations\n      ) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: nextSpan?.node.marks ?? [],\n        }\n      }\n    }\n  }\n\n  if (atTheBeginningOfSpan && !spanIsEmpty && !!previousSpan) {\n    if (previousSpanHasAnnotations) {\n      return {\n        state: 'changed',\n        marks,\n        previousMarks: previousSpan?.node.marks ?? [],\n      }\n    } else {\n      return {\n        state: 'changed',\n        previousMarks: marks,\n        marks: (previousSpan?.node.marks ?? []).filter((mark) =>\n          decorators.includes(mark),\n        ),\n      }\n    }\n  }\n\n  return {\n    state: 'unchanged',\n    marks,\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: BlockPath}> = []\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n","import {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getMarkState} from './selector.get-mark-state'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const markState = getMarkState(snapshot)\n\n  const activeAnnotations = (markState?.marks ?? []).filter(\n    (mark) =>\n      !snapshot.context.schema.decorators\n        .map((decorator) => decorator.name)\n        .includes(mark),\n  )\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isTextBlock(snapshot.context, block.node)\n      ? (block.node.markDefs ?? [])\n      : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    activeAnnotations.includes(markDef._key),\n  )\n}\n","import {isTextBlock, type PortableTextListBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeyedSegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeyedSegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {sliceBlocks} from '../utils/util.slice-blocks'\n\n/**\n * @public\n */\nexport const getSelectedValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  const selection = snapshot.context.selection\n\n  if (!selection) {\n    return []\n  }\n\n  const startPoint = getSelectionStartPoint(selection)\n  const endPoint = getSelectionEndPoint(selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return []\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return []\n  }\n\n  const startBlock = snapshot.context.value.at(startBlockIndex)\n  const slicedStartBlock = startBlock\n    ? sliceBlocks({\n        context: snapshot.context,\n        blocks: [startBlock],\n      }).at(0)\n    : undefined\n\n  if (startBlockIndex === endBlockIndex) {\n    return slicedStartBlock ? [slicedStartBlock] : []\n  }\n\n  const endBlock = snapshot.context.value.at(endBlockIndex)\n  const slicedEndBlock = endBlock\n    ? sliceBlocks({\n        context: snapshot.context,\n        blocks: [endBlock],\n      }).at(0)\n    : undefined\n\n  const middleBlocks = snapshot.context.value.slice(\n    startBlockIndex + 1,\n    endBlockIndex,\n  )\n\n  return [\n    ...(slicedStartBlock ? [slicedStartBlock] : []),\n    ...middleBlocks,\n    ...(slicedEndBlock ? [slicedEndBlock] : []),\n  ]\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = (snapshot) => {\n  const selectedValue = getSelectedValue(snapshot)\n\n  return selectedValue.reduce((text, block) => {\n    if (!isTextBlock(snapshot.context, block)) {\n      return text\n    }\n\n    return (\n      text +\n      block.children.reduce((text, child) => {\n        if (isSpan(snapshot.context, child)) {\n          return text + child.text\n        }\n\n        return text\n      }, '')\n    )\n  }, '')\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isEqualPaths} from '../utils/util.is-equal-paths'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  return (\n    isEqualPaths(\n      snapshot.context.selection.anchor.path,\n      snapshot.context.selection.focus.path,\n    ) &&\n    snapshot.context.selection.anchor.offset ===\n      snapshot.context.selection.focus.offset\n  )\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = (snapshot) => {\n  return snapshot.context.selection !== null && !isSelectionCollapsed(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils/util.block-offset'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        context: snapshot.context,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusInlineObject: EditorSelector<\n  {node: PortableTextObject; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && !isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {PortableTextListBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {isListBlock} from '../utils/parse-blocks'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node)\n    ? {node: focusTextBlock.node, path: focusTextBlock.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key)\n\n  if (index === undefined || index === snapshot.context.value.length - 1) {\n    return undefined\n  }\n\n  const nextBlock = snapshot.context.value.at(index + 1)\n\n  return nextBlock\n    ? {node: nextBlock, path: [{_key: nextBlock._key}]}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key)\n\n  if (index === undefined || index === 0) {\n    return undefined\n  }\n\n  const previousBlock = snapshot.context.value.at(index - 1)\n\n  return previousBlock\n    ? {node: previousBlock, path: [{_key: previousBlock._key}]}\n    : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: BlockPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedTextBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedTextBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionEndChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionStartChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveAnnotationsMarks(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const markState = getMarkState(snapshot)\n\n  return (markState?.marks ?? []).filter(\n    (mark) =>\n      !schema.decorators.map((decorator) => decorator.name).includes(mark),\n  )\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveAnnotationsMarks} from './selector.get-active-annotation-marks'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * Check whether an annotation is active in the given `snapshot`.\n *\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n  options?: {\n    /**\n     * Choose whether the annotation has to take up the entire selection in the\n     * `snapshot` or if the annotation can be partially selected.\n     *\n     * Defaults to 'full'\n     */\n    mode?: 'partial' | 'full'\n  },\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const mode = options?.mode ?? 'full'\n\n    if (mode === 'partial') {\n      const selectedValue = getSelectedValue(snapshot)\n\n      const selectionMarkDefs = selectedValue.flatMap((block) =>\n        isTextBlock(snapshot.context, block) ? (block.markDefs ?? []) : [],\n      )\n\n      return selectionMarkDefs.some((markDef) => markDef._type === annotation)\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isTextBlock(snapshot.context, block.node)\n        ? (block.node.markDefs ?? [])\n        : [],\n    )\n    const activeAnnotations = getActiveAnnotationsMarks(snapshot)\n    const activeMarkDefs = selectionMarkDefs.filter(\n      (markDef) =>\n        markDef._type === annotation &&\n        activeAnnotations.includes(markDef._key),\n    )\n\n    return activeMarkDefs.length > 0\n  }\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveDecorators(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const decoratorState = snapshot.decoratorState\n  const markState = getMarkState(snapshot)\n  const decorators = schema.decorators.map((decorator) => decorator.name)\n\n  const markStateDecorators = (markState?.marks ?? []).filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  let activeDecorators: Array<string> = markStateDecorators\n\n  for (const decorator in decoratorState) {\n    if (decoratorState[decorator] === false) {\n      activeDecorators = activeDecorators.filter(\n        (activeDecorator) => activeDecorator !== decorator,\n      )\n    } else if (decoratorState[decorator] === true) {\n      if (!activeDecorators.includes(decorator)) {\n        activeDecorators.push(decorator)\n      }\n    }\n  }\n\n  return activeDecorators\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveDecorators} from './selector.get-active-decorators'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    const activeDecorators = getActiveDecorators(snapshot)\n\n    return activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = getBlockEndPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = getBlockStartPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSnapshot} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * Returns:\n *\n * - `-1` if `pointA` is before `pointB`\n * - `0` if `pointA` and `pointB` are equal\n * - `1` if `pointA` is after `pointB`.\n */\nexport function comparePoints(\n  snapshot: EditorSnapshot,\n  pointA: EditorSelectionPoint,\n  pointB: EditorSelectionPoint,\n): -1 | 0 | 1 {\n  const blockKeyA = getBlockKeyFromSelectionPoint(pointA)\n  const blockKeyB = getBlockKeyFromSelectionPoint(pointB)\n\n  if (!blockKeyA) {\n    throw new Error(`Cannot compare points: no block key found for ${pointA}`)\n  }\n\n  if (!blockKeyB) {\n    throw new Error(`Cannot compare points: no block key found for ${pointB}`)\n  }\n\n  const blockIndexA = snapshot.blockIndexMap.get(blockKeyA)\n  const blockIndexB = snapshot.blockIndexMap.get(blockKeyB)\n\n  if (blockIndexA === undefined) {\n    throw new Error(`Cannot compare points: block \"${blockKeyA}\" not found`)\n  }\n\n  if (blockIndexB === undefined) {\n    throw new Error(`Cannot compare points: block \"${blockKeyB}\" not found`)\n  }\n\n  if (blockIndexA < blockIndexB) {\n    return -1\n  }\n\n  if (blockIndexA > blockIndexB) {\n    return 1\n  }\n\n  // Same block - need to compare at child level\n  const block = snapshot.context.value.at(blockIndexA)\n\n  if (!block || !isTextBlock(snapshot.context, block)) {\n    // Block objects - same block means equal position\n    return 0\n  }\n\n  const childKeyA = getChildKeyFromSelectionPoint(pointA)\n  const childKeyB = getChildKeyFromSelectionPoint(pointB)\n\n  if (!childKeyA) {\n    throw new Error(`Cannot compare points: no child key found for ${pointA}`)\n  }\n\n  if (!childKeyB) {\n    throw new Error(`Cannot compare points: no child key found for ${pointB}`)\n  }\n\n  // Find child indices\n  let childIndexA: number | undefined\n  let childIndexB: number | undefined\n\n  for (let i = 0; i < block.children.length; i++) {\n    const child = block.children.at(i)\n\n    if (!child) {\n      continue\n    }\n\n    if (child._key === childKeyA && child._key === childKeyB) {\n      // Same child - compare offsets directly\n      if (pointA.offset < pointB.offset) {\n        return -1\n      }\n\n      if (pointA.offset > pointB.offset) {\n        return 1\n      }\n\n      return 0\n    }\n\n    if (child._key === childKeyA) {\n      childIndexA = i\n    }\n\n    if (child._key === childKeyB) {\n      childIndexB = i\n    }\n\n    if (childIndexA !== undefined && childIndexB !== undefined) {\n      break\n    }\n  }\n\n  if (childIndexA === undefined) {\n    throw new Error(`Cannot compare points: child \"${childKeyA}\" not found`)\n  }\n\n  if (childIndexB === undefined) {\n    throw new Error(`Cannot compare points: child \"${childKeyB}\" not found`)\n  }\n\n  if (childIndexA < childIndexB) {\n    return -1\n  }\n\n  if (childIndexA > childIndexB) {\n    return 1\n  }\n\n  // Same child index but different keys (shouldn't happen)\n  return 0\n}\n","import type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {\n  getSelectionEndPoint,\n  getSelectionStartPoint,\n  isEqualSelectionPoints,\n} from '../utils'\nimport {comparePoints} from '../utils/util.compare-points'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport type {EditorSnapshot} from './../editor/editor-snapshot'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const editorSelection = snapshot.context.selection\n\n    if (!selection || !editorSelection) {\n      return false\n    }\n\n    const selectionStart = getSelectionStartPoint(selection)\n    const selectionEnd = getSelectionEndPoint(selection)\n    const editorSelectionStart = getSelectionStartPoint(editorSelection)\n    const editorSelectionEnd = getSelectionEndPoint(editorSelection)\n\n    const selectionStartBlockKey = getBlockKeyFromSelectionPoint(selectionStart)\n    const selectionEndBlockKey = getBlockKeyFromSelectionPoint(selectionEnd)\n    const editorSelectionStartBlockKey =\n      getBlockKeyFromSelectionPoint(editorSelectionStart)\n    const editorSelectionEndBlockKey =\n      getBlockKeyFromSelectionPoint(editorSelectionEnd)\n\n    if (\n      !selectionStartBlockKey ||\n      !selectionEndBlockKey ||\n      !editorSelectionStartBlockKey ||\n      !editorSelectionEndBlockKey\n    ) {\n      return false\n    }\n\n    const selectionStartBlockIndex = snapshot.blockIndexMap.get(\n      selectionStartBlockKey,\n    )\n    const selectionEndBlockIndex =\n      snapshot.blockIndexMap.get(selectionEndBlockKey)\n    const editorSelectionStartBlockIndex = snapshot.blockIndexMap.get(\n      editorSelectionStartBlockKey,\n    )\n    const editorSelectionEndBlockIndex = snapshot.blockIndexMap.get(\n      editorSelectionEndBlockKey,\n    )\n\n    if (\n      selectionStartBlockIndex === undefined ||\n      selectionEndBlockIndex === undefined ||\n      editorSelectionStartBlockIndex === undefined ||\n      editorSelectionEndBlockIndex === undefined\n    ) {\n      return false\n    }\n\n    const [selectionMinBlockIndex, selectionMaxBlockIndex] =\n      selectionStartBlockIndex <= selectionEndBlockIndex\n        ? [selectionStartBlockIndex, selectionEndBlockIndex]\n        : [selectionEndBlockIndex, selectionStartBlockIndex]\n    const [editorSelectionMinBlockIndex, editorSelectionMaxBlockIndex] =\n      editorSelectionStartBlockIndex <= editorSelectionEndBlockIndex\n        ? [editorSelectionStartBlockIndex, editorSelectionEndBlockIndex]\n        : [editorSelectionEndBlockIndex, editorSelectionStartBlockIndex]\n\n    if (selectionMaxBlockIndex < editorSelectionMinBlockIndex) {\n      return false\n    }\n\n    if (selectionMinBlockIndex > editorSelectionMaxBlockIndex) {\n      return false\n    }\n\n    return hasPointLevelOverlap(\n      snapshot,\n      selectionStart,\n      selectionEnd,\n      editorSelectionStart,\n      editorSelectionEnd,\n    )\n  }\n}\n\n/**\n * Check if selections overlap at the point level.\n * Called after confirming block ranges overlap.\n */\nfunction hasPointLevelOverlap(\n  snapshot: EditorSnapshot,\n  selectionStart: EditorSelectionPoint,\n  selectionEnd: EditorSelectionPoint,\n  editorSelectionStart: EditorSelectionPoint,\n  editorSelectionEnd: EditorSelectionPoint,\n): boolean {\n  // Check for exact equality first\n  if (\n    isEqualSelectionPoints(selectionStart, editorSelectionStart) &&\n    isEqualSelectionPoints(selectionEnd, editorSelectionEnd)\n  ) {\n    return true\n  }\n\n  // Compare selection start against editor selection bounds\n  const selectionStartVsEditorSelectionStart = comparePoints(\n    snapshot,\n    selectionStart,\n    editorSelectionStart,\n  )\n  const selectionStartVsEditorSelectionEnd = comparePoints(\n    snapshot,\n    selectionStart,\n    editorSelectionEnd,\n  )\n\n  // Compare selection end against editor selection bounds\n  const selectionEndVsEditorSelectionStart = comparePoints(\n    snapshot,\n    selectionEnd,\n    editorSelectionStart,\n  )\n  const selectionEndVsEditorSelectionEnd = comparePoints(\n    snapshot,\n    selectionEnd,\n    editorSelectionEnd,\n  )\n\n  // Compare editor selection bounds against selection bounds\n  const editorSelectionStartVsSelectionStart = comparePoints(\n    snapshot,\n    editorSelectionStart,\n    selectionStart,\n  )\n  const editorSelectionEndVsSelectionEnd = comparePoints(\n    snapshot,\n    editorSelectionEnd,\n    selectionEnd,\n  )\n\n  // Derive boolean flags\n  const selectionStartBeforeEditorSelectionStart =\n    selectionStartVsEditorSelectionStart === -1\n  const selectionStartAfterEditorSelectionEnd =\n    selectionStartVsEditorSelectionEnd === 1\n  const selectionEndBeforeEditorSelectionStart =\n    selectionEndVsEditorSelectionStart === -1\n  const selectionEndAfterEditorSelectionEnd =\n    selectionEndVsEditorSelectionEnd === 1\n\n  const editorSelectionStartBeforeSelectionStart =\n    editorSelectionStartVsSelectionStart === -1\n  const editorSelectionStartAfterSelectionStart =\n    editorSelectionStartVsSelectionStart === 1\n  const editorSelectionEndBeforeSelectionEnd =\n    editorSelectionEndVsSelectionEnd === -1\n  const editorSelectionEndAfterSelectionEnd =\n    editorSelectionEndVsSelectionEnd === 1\n\n  const selectionStartEqualEditorSelectionEnd = isEqualSelectionPoints(\n    selectionStart,\n    editorSelectionEnd,\n  )\n  const selectionEndEqualEditorSelectionStart = isEqualSelectionPoints(\n    selectionEnd,\n    editorSelectionStart,\n  )\n\n  // If all relative position checks fail, selections don't overlap\n  if (\n    !selectionEndEqualEditorSelectionStart &&\n    !selectionStartEqualEditorSelectionEnd &&\n    !editorSelectionStartBeforeSelectionStart &&\n    !editorSelectionStartAfterSelectionStart &&\n    !editorSelectionEndBeforeSelectionEnd &&\n    !editorSelectionEndAfterSelectionEnd\n  ) {\n    return false\n  }\n\n  // Selection ends before editor selection starts\n  if (\n    selectionEndBeforeEditorSelectionStart &&\n    !selectionEndEqualEditorSelectionStart\n  ) {\n    return false\n  }\n\n  // Selection starts after editor selection ends\n  if (\n    selectionStartAfterEditorSelectionEnd &&\n    !selectionStartEqualEditorSelectionEnd\n  ) {\n    return false\n  }\n\n  // Editor selection is entirely after the input selection start\n  if (\n    !editorSelectionStartBeforeSelectionStart &&\n    editorSelectionStartAfterSelectionStart &&\n    !editorSelectionEndBeforeSelectionEnd &&\n    editorSelectionEndAfterSelectionEnd\n  ) {\n    return !selectionEndEqualEditorSelectionStart\n  }\n\n  // Editor selection is entirely before the input selection end\n  if (\n    editorSelectionStartBeforeSelectionStart &&\n    !editorSelectionStartAfterSelectionStart &&\n    editorSelectionEndBeforeSelectionEnd &&\n    !editorSelectionEndAfterSelectionEnd\n  ) {\n    return !selectionStartEqualEditorSelectionEnd\n  }\n\n  // If any of these conditions is false, there's overlap\n  if (\n    !selectionStartAfterEditorSelectionEnd ||\n    !selectionStartBeforeEditorSelectionStart ||\n    !selectionEndAfterEditorSelectionEnd ||\n    !selectionEndBeforeEditorSelectionStart\n  ) {\n    return true\n  }\n\n  return false\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: startBlock,\n  })\n  const endBlockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: endBlock,\n  })\n\n  return (\n    isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n"],"names":["isBlockPath","path","firstSegment","at","length","undefined","isRecord","_key","value","isSelectionExpanded","selection","isSelectionCollapsed","getFocusBlock","snapshot","context","key","getBlockKeyFromSelectionPoint","focus","index","blockIndexMap","get","node","getFocusTextBlock","focusBlock","isTextBlock","getFocusChild","getChildKeyFromSelectionPoint","children","find","span","getFocusSpan","focusChild","isSpan","getSelectionEndBlock","endPoint","getSelectionEndPoint","anchor","backward","getNextSpan","selectionEndBlock","selectionEndPoint","selectionEndPointChildKey","endPointChildFound","nextSpan","child","getSelectionStartBlock","startPoint","getSelectionStartPoint","getPreviousSpan","selectionStartBlock","selectionStartPoint","selectionStartPointChildKey","previousSpan","getSelectedChildren","options","filter","startBlockKey","endBlockKey","startChildKey","endChildKey","startBlockIndex","endBlockIndex","selectedChildren","minBlockIndex","Math","min","maxBlockIndex","max","blocks","slice","startChildFound","block","isStartBlock","isEndBlock","isMiddleBlock","isStartChild","isEndChild","addChild","push","offset","text","getSelectedSpans","getMarkState","spanSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","focusSpan","selectedSpans","marks","mark","some","spanMark","state","decorators","schema","map","decorator","name","marksWithoutAnnotations","includes","spanHasAnnotations","spanIsEmpty","atTheBeginningOfSpan","atTheEndOfSpan","nextSpanAnnotations","spanAnnotations","previousSpanHasAnnotations","previousSpanHasSameAnnotations","every","previousSpanHasSameAnnotation","previousSpanHasSameMarks","nextSpanSharesSomeAnnotations","previousMarks","getSelectedBlocks","selectedBlocks","startKey","endKey","slicedValue","getActiveAnnotations","activeAnnotations","flatMap","markDefs","markDef","getActiveListItem","selectedTextBlocks","firstTextBlock","firstListItem","listItem","getActiveStyle","firstStyle","style","getNextInlineObject","focusTextBlock","isKeyedSegment","inlineObject","getPreviousInlineObject","getSelectedValue","startBlock","slicedStartBlock","sliceBlocks","endBlock","slicedEndBlock","middleBlocks","getSelectionText","reduce","isEqualPaths","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","split","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","caretWordEndSelectionPoint","caretWordSelection","getFocusBlockObject","getFocusInlineObject","getFocusListBlock","isListBlock","getLastBlock","getNextBlock","nextBlock","getPreviousBlock","previousBlock","getSelectedTextBlocks","getSelectionEndChild","getSelectionStartChild","getActiveAnnotationsMarks","isActiveAnnotation","annotation","mode","_type","selectionMarkDefs","getActiveDecorators","decoratorState","markState","activeDecorators","activeDecorator","isActiveDecorator","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","isEqualSelectionPoints","isAtTheStartOfBlock","comparePoints","pointA","pointB","blockKeyA","blockKeyB","Error","blockIndexA","blockIndexB","childKeyA","childKeyB","childIndexA","childIndexB","i","isOverlappingSelection","editorSelection","selectionStart","selectionEnd","editorSelectionStart","editorSelectionEnd","selectionStartBlockKey","selectionEndBlockKey","editorSelectionStartBlockKey","editorSelectionEndBlockKey","selectionStartBlockIndex","selectionEndBlockIndex","editorSelectionStartBlockIndex","editorSelectionEndBlockIndex","selectionMinBlockIndex","selectionMaxBlockIndex","editorSelectionMinBlockIndex","editorSelectionMaxBlockIndex","hasPointLevelOverlap","selectionStartVsEditorSelectionStart","selectionStartVsEditorSelectionEnd","selectionEndVsEditorSelectionStart","selectionEndVsEditorSelectionEnd","editorSelectionStartVsSelectionStart","editorSelectionEndVsSelectionEnd","selectionStartBeforeEditorSelectionStart","selectionStartAfterEditorSelectionEnd","selectionEndBeforeEditorSelectionStart","selectionEndAfterEditorSelectionEnd","editorSelectionStartBeforeSelectionStart","editorSelectionStartAfterSelectionStart","editorSelectionEndBeforeSelectionEnd","editorSelectionEndAfterSelectionEnd","selectionStartEqualEditorSelectionEnd","selectionEndEqualEditorSelectionStart","isSelectingEntireBlocks","startBlockStartPoint","endBlockEndPoint"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1444, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/internal-utils/global-scope.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/internal-utils/globally-scoped-context.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/editor/editor-context.tsx","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/editor/use-editor.ts"],"sourcesContent":["/**\n * Gets the global scope instance in a given environment.\n *\n * The strategy is to return the most modern, and if not, the most common:\n * - The `globalThis` variable is the modern approach to accessing the global scope\n * - The `window` variable is the global scope in a web browser\n * - The `self` variable is the global scope in workers and others\n * - The `global` variable is the global scope in Node.js\n */\nfunction getGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis\n  }\n  if (typeof window !== 'undefined') {\n    return window\n  }\n  if (typeof self !== 'undefined') {\n    return self\n  }\n  if (typeof global !== 'undefined') {\n    return global\n  }\n\n  throw new Error('@portabletext/editor: could not locate global scope')\n}\n\nexport const globalScope = getGlobalScope() as any\n","import {createContext, type Context} from 'react'\nimport {globalScope} from './global-scope'\n\n/**\n * As `@portabletext/editor` is declared as a dependency, and may be\n * duplicated, sometimes across major versions it's critical that vital\n * React Contexts are shared even when there is a duplicate.\n *\n * We have to support a Sanity Plugin being able to call hooks like\n * `useEditor`, and then read the context setup by `sanity`, which calls\n * `EditorProvider`, even if the provider and hook are different instances in\n * memory.\n *\n * For this reason it's vital that all changes to globally scoped providers\n * remain fully backwards compatible.\n */\nexport function createGloballyScopedContext<\n  ContextType,\n  const T extends ContextType = ContextType,\n>(\n  /**\n   * Enforce that all Symbol.for keys used for globally scoped contexts have a predictable prefix\n   */\n  key: `@portabletext/editor/context/${string}`,\n  defaultValue: T,\n): Context<ContextType> {\n  const symbol = Symbol.for(key)\n\n  /**\n   * Prevent errors about re-renders on React SSR on Next.js App Router\n   */\n  if (typeof document === 'undefined') {\n    return createContext<ContextType>(defaultValue)\n  }\n\n  globalScope[symbol] = globalScope[symbol] ?? createContext<T>(defaultValue)\n\n  return globalScope[symbol]\n}\n","import type {Editor} from '../editor'\nimport {createGloballyScopedContext} from '../internal-utils/globally-scoped-context'\n\nexport const EditorContext = createGloballyScopedContext<Editor | null>(\n  '@portabletext/editor/context/editor',\n  null,\n)\n","import React from 'react'\nimport {EditorContext} from './editor-context'\n\n/**\n * @public\n * Get the current editor context from the `EditorProvider`.\n * Must be used inside the `EditorProvider` component.\n * @returns The current editor object.\n * @example\n * ```tsx\n * import { useEditor } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  const editor = useEditor()\n * }\n * ```\n * @group Hooks\n */\nexport function useEditor() {\n  const editor = React.useContext(EditorContext)\n\n  if (!editor) {\n    throw new Error('No Editor set. Use EditorProvider to set one.')\n  }\n\n  return editor\n}\n"],"names":["getGlobalScope","globalThis","window","self","global","Error","globalScope","createGloballyScopedContext","key","defaultValue","symbol","Symbol","for","document","createContext","EditorContext","useEditor","editor","React","useContext"],"mappings":";;;;;;;;AASA,SAASA,iBAAiB;IACxB,IAAI,OAAOC,aAAe,KACxB,OAAOA;IAET,IAAI,OAAOC,SAAW,KACpB,OAAOA;IAET,IAAI,OAAOC,OAAS,KAClB,OAAOA;IAET,IAAI,OAAOC,sCAAW,KACpB,OAAOA;IAGT,MAAM,IAAIC,MAAM,qDAAqD;AACvE;AAEO,MAAMC,cAAcN,eAAAA;ACVpB,SAASO,4BAOdC,GAAAA,EACAC,YAAAA,EACsB;IACtB,MAAMC,SAASC,OAAOC,GAAAA,CAAIJ,GAAG;IAK7B,OAAI,OAAOK,WAAa,UACfC,2aAAAA,EAA2BL,YAAY,IAAA,CAGhDH,WAAAA,CAAYI,MAAM,CAAA,GAAIJ,WAAAA,CAAYI,MAAM,CAAA,QAAKI,2aAAAA,EAAiBL,YAAY,GAEnEH,WAAAA,CAAYI,MAAM,CAAA;AAC3B;ACnCO,MAAMK,gBAAgBR,4BAC3B,uCACA,IACF;ACYO,SAAAS,YAAA;IACL,MAAAC,SAAeC,qaAAAA,CAAKC,UAAAA,CAAYJ,aAAa;IAE7C,IAAI,CAACE,QACH,MAAM,IAAIZ,MAAM,+CAA+C;IAChE,OAEMY;AAAM","debugId":null}},
    {"offset": {"line": 1485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/behaviors/index.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/behaviors/behavior.types.action.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/behaviors/behavior.types.behavior.ts"],"sourcesContent":["import type {EditorDom} from '../editor/editor-dom'\nimport type {EditorSnapshot} from '../editor/editor-snapshot'\nimport type {PickFromUnion} from '../type-utils'\nimport type {\n  CustomBehaviorEvent,\n  ExternalBehaviorEvent,\n  NativeBehaviorEvent,\n  SyntheticBehaviorEvent,\n} from './behavior.types.event'\n\n/**\n * @beta\n */\nexport type BehaviorAction =\n  | {\n      type: 'execute'\n      event: SyntheticBehaviorEvent\n    }\n  | {\n      type: 'forward'\n      event: NativeBehaviorEvent | SyntheticBehaviorEvent | CustomBehaviorEvent\n    }\n  | {\n      type: 'raise'\n      event: SyntheticBehaviorEvent | CustomBehaviorEvent\n    }\n  | {\n      type: 'effect'\n      effect: (payload: {\n        /**\n         * Send a Behavior Event back into the Editor.\n         *\n         * @example\n         * ```ts\n         * defineBehavior({\n         *   on: '...',\n         *   actions: [\n         *     () => [\n         *       effect(({send}) => {\n         *         doSomethingAsync()\n         *           .then(() => {\n         *             send({\n         *               type: '...',\n         *             })\n         *           })\n         *       })\n         *     ],\n         *   ],\n         * })\n         * ```\n         */\n        send: (event: ExternalBehaviorEvent) => void\n      }) => void\n    }\n\n/**\n * @beta\n */\nexport function execute(\n  event: SyntheticBehaviorEvent,\n): PickFromUnion<BehaviorAction, 'type', 'execute'> {\n  return {type: 'execute', event}\n}\n\n/**\n * @beta\n */\nexport function forward(\n  event: NativeBehaviorEvent | SyntheticBehaviorEvent | CustomBehaviorEvent,\n): PickFromUnion<BehaviorAction, 'type', 'forward'> {\n  return {type: 'forward', event}\n}\n\n/**\n * @beta\n */\nexport function raise(\n  event: SyntheticBehaviorEvent | CustomBehaviorEvent,\n): PickFromUnion<BehaviorAction, 'type', 'raise'> {\n  return {type: 'raise', event}\n}\n\n/**\n * @beta\n */\nexport function effect(\n  effect: PickFromUnion<BehaviorAction, 'type', 'effect'>['effect'],\n): PickFromUnion<BehaviorAction, 'type', 'effect'> {\n  return {type: 'effect', effect}\n}\n\n/**\n * @beta\n */\nexport type BehaviorActionSet<TBehaviorEvent, TGuardResponse> = (\n  payload: {\n    snapshot: EditorSnapshot\n    event: TBehaviorEvent\n    dom: EditorDom\n  },\n  guardResponse: TGuardResponse,\n) => Array<BehaviorAction>\n","import type {BehaviorActionSet} from './behavior.types.action'\nimport type {\n  BehaviorEvent,\n  BehaviorEventTypeNamespace,\n  CustomBehaviorEvent,\n  ResolveBehaviorEvent,\n} from './behavior.types.event'\nimport type {BehaviorGuard} from './behavior.types.guard'\n\n/**\n * @beta\n */\nexport type Behavior<\n  TBehaviorEventType extends\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'] =\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'],\n  TGuardResponse = true,\n  TBehaviorEvent extends ResolveBehaviorEvent<TBehaviorEventType> =\n    ResolveBehaviorEvent<TBehaviorEventType>,\n> = {\n  /**\n   * Editor Event that triggers this Behavior.\n   */\n  on: TBehaviorEventType\n  /**\n   * Predicate function that determines if the Behavior should be executed.\n   * Returning a non-nullable value from the guard will pass the value to the\n   * actions and execute them.\n   */\n  guard?: BehaviorGuard<TBehaviorEvent, TGuardResponse>\n  /**\n   * Array of Behavior Action sets.\n   * Each set represents a step in the history stack.\n   */\n  actions: Array<BehaviorActionSet<TBehaviorEvent, TGuardResponse>>\n}\n\n/**\n * @beta\n *\n * @example\n *\n * ```tsx\n * const noLowerCaseA = defineBehavior({\n *   on: 'insert.text',\n *   guard: ({event, snapshot}) => event.text === 'a',\n *   actions: [({event, snapshot}) => [{type: 'insert.text', text: 'A'}]],\n * })\n * ```\n *\n */\nexport function defineBehavior<\n  TPayload extends Record<string, unknown>,\n  TBehaviorEventType extends\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'] = CustomBehaviorEvent['type'],\n  TGuardResponse = true,\n>(\n  behavior: Behavior<\n    TBehaviorEventType,\n    TGuardResponse,\n    ResolveBehaviorEvent<TBehaviorEventType, TPayload>\n  >,\n): Behavior\nexport function defineBehavior<\n  TPayload extends never = never,\n  TBehaviorEventType extends\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'] = BehaviorEvent['type'],\n  TGuardResponse = true,\n  TBehaviorEvent extends ResolveBehaviorEvent<TBehaviorEventType, TPayload> =\n    ResolveBehaviorEvent<TBehaviorEventType, TPayload>,\n>(\n  behavior: Behavior<TBehaviorEventType, TGuardResponse, TBehaviorEvent>,\n): Behavior {\n  return behavior as unknown as Behavior\n}\n"],"names":["execute","event","type","forward","raise","effect","defineBehavior","behavior"],"mappings":";;;;;;;;;;;;AA0DO,SAASA,QACdC,KAAAA,EACkD;IAClD,OAAO;QAACC,MAAM;QAAWD;IAAAA;AAC3B;AAKO,SAASE,QACdF,KAAAA,EACkD;IAClD,OAAO;QAACC,MAAM;QAAWD;IAAAA;AAC3B;AAKO,SAASG,MACdH,KAAAA,EACgD;IAChD,OAAO;QAACC,MAAM;QAASD;IAAAA;AACzB;AAKO,SAASI,OACdA,OAAAA,EACiD;IACjD,OAAO;QAACH,MAAM;QAAUG,QAAAA;IAAAA;AAC1B;ACpBO,SAASC,eAUdC,QAAAA,EACU;IACV,OAAOA;AACT","debugId":null}},
    {"offset": {"line": 1530, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/plugins/index.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/plugins/plugin.behavior.tsx","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/plugins/plugin.editor-ref.tsx","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/plugins/plugin.event-listener.tsx"],"sourcesContent":["import {useEffect} from 'react'\nimport type {Behavior} from '../behaviors/behavior.types.behavior'\nimport {useEditor} from '../editor/use-editor'\n\n/**\n * @beta\n */\nexport function BehaviorPlugin(props: {behaviors: Array<Behavior>}) {\n  const editor = useEditor()\n\n  useEffect(() => {\n    const unregisterBehaviors = props.behaviors.map((behavior) =>\n      editor.registerBehavior({behavior}),\n    )\n\n    return () => {\n      unregisterBehaviors.forEach((unregister) => {\n        unregister()\n      })\n    }\n  }, [editor, props.behaviors])\n\n  return null\n}\n","import React from 'react'\nimport type {Editor} from '../editor'\nimport {useEditor} from '../editor/use-editor'\n\n/**\n * @beta\n */\nexport const EditorRefPlugin = React.forwardRef<Editor | null>((_, ref) => {\n  const editor = useEditor()\n\n  const portableTextEditorRef = React.useRef(editor)\n\n  React.useImperativeHandle(ref, () => portableTextEditorRef.current, [])\n\n  return null\n})\nEditorRefPlugin.displayName = 'EditorRefPlugin'\n","import {useEffect} from 'react'\nimport type {EditorEmittedEvent} from '../editor/relay-machine'\nimport {useEditor} from '../editor/use-editor'\n\n/**\n * @public\n * Listen for events emitted by the editor. Must be used inside `EditorProvider`. Events available include:\n *  - 'blurred'\n *  - 'done loading'\n *  - 'editable'\n *  - 'error'\n *  - 'focused'\n *  - 'invalid value'\n *  - 'loading'\n *  - 'mutation'\n *  - 'patch'\n *  - 'read only'\n *  - 'ready'\n *  - 'selection'\n *  - 'value changed'\n *\n * @example\n * Listen and log events.\n * ```tsx\n * import {EditorProvider} from '@portabletext/editor'\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n *\n * function MyComponent() {\n *  return (\n *  <EditorProvider>\n *   <EventListenerPlugin\n *    on={(event) => {\n *     console.log(event)\n *    }\n *   } />\n *   { ... }\n * </EditorProvider>\n *  )\n * }\n * ```\n * @example\n * Handle events when there is a mutation.\n * ```tsx\n * <EventListenerPlugin\n *  on={(event) => {\n *    if (event.type === 'mutation') {\n *      console.log('Value changed:', event.snapshot)\n *    }\n *  }}\n * />\n * ```\n * @group Components\n */\nexport function EventListenerPlugin(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n\n  useEffect(() => {\n    const subscription = editor.on('*', props.on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor, props.on])\n\n  return null\n}\n"],"names":["BehaviorPlugin","props","$","_c","editor","useEditor","t0","t1","behaviors","unregisterBehaviors","map","behavior","registerBehavior","forEach","_temp","useEffect","unregister","EditorRefPlugin","React","forwardRef","_","ref","portableTextEditorRef","useRef","Symbol","for","current","useImperativeHandle","displayName","EventListenerPlugin","on","subscription","unsubscribe"],"mappings":";;;;;;;;;;;;;;AAOO,SAAAA,eAAAC,KAAAA,EAAA;IAAA,MAAAC,QAAAC,6aAAAA,EAAA,CAAA,GACLC,aAAeC,ibAAAA,CAAAA;IAAW,IAAAC,IAAAC;IAAA,OAAAL,CAAAA,CAAAA,EAAAA,KAAAE,UAAAF,CAAAA,CAAA,CAAA,CAAA,KAAAD,MAAAO,SAAAA,GAAAA,CAEhBF,KAAAA,MAAA;QACR,MAAAG,sBAA4BR,MAAKO,SAAAA,CAAUE,GAAAA,CAAKC,CAAAA,WAC9CP,OAAMQ,gBAAAA,CAAkB;gBAAAD;YAAAA,CAAU,CACpC;QAAC,OAEM,MAAA;YACLF,oBAAmBI,OAAAA,CAASC,KAE3B;QAAC;IACH,GACAP,KAAAA;QAACH;QAAQH,MAAKO,SAAU;KAAA,EAACN,CAAAA,CAAAA,EAAAA,GAAAE,QAAAF,CAAAA,CAAA,CAAA,CAAA,GAAAD,MAAAO,SAAAA,EAAAN,CAAAA,CAAAA,EAAAA,GAAAI,IAAAJ,CAAAA,CAAAA,EAAAA,GAAAK,EAAAA,IAAAA,CAAAD,KAAAJ,CAAAA,CAAA,CAAA,CAAA,EAAAK,KAAAL,CAAAA,CAAA,CAAA,CAAA,OAV5Ba,uaAAAA,EAAUT,IAUPC,EAAyB,GAErB;AAAI;AAfN,SAAAO,MAAAE,UAAAA,EAAA;IAUCA,WAAAA;AAAY;ACVb,MAAMC,kBAAkBC,qaAAAA,CAAMC,UAAAA,CAA0B,CAAAC,GAAAC,QAAA;IAAA,MAAAnB,QAAAC,6aAAAA,EAAA,CAAA,GAC7DC,aAAeC,ibAAAA,KAEfiB,wBAA8BJ,qaAAAA,CAAKK,MAAAA,CAAQnB,MAAM;IAAC,IAAAE,IAAAC;IAAA,OAAAL,CAAAA,CAAA,CAAA,CAAA,KAAAsB,aAAAA,GAAAA,OAAAC,GAAAA,CAAA,2BAAA,IAAA,CAEnBnB,KAAAA,IAAMgB,sBAAqBI,OAAAA,EAAUnB,KAAA,CAAA,CAAA,EAAEL,CAAAA,CAAAA,EAAAA,GAAAI,IAAAJ,CAAAA,CAAAA,EAAAA,GAAAK,EAAAA,IAAAA,CAAAD,KAAAJ,CAAAA,CAAA,CAAA,CAAA,EAAAK,KAAAL,CAAAA,CAAA,CAAA,CAAA,GAAtEgB,qaAAAA,CAAKS,mBAAAA,CAAqBN,KAAKf,IAAqCC,EAAE,GAE/D;AAAI,CACZ;AACDU,gBAAgBW,WAAAA,GAAc;ACqCvB,SAAAC,oBAAA5B,KAAAA,EAAA;IAAA,MAAAC,QAAAC,6aAAAA,EAAA,CAAA,GAGLC,aAAeC,ibAAAA,CAAAA;IAAW,IAAAC,IAAAC;IAAA,OAAAL,CAAAA,CAAAA,EAAAA,KAAAE,UAAAF,CAAAA,CAAA,CAAA,CAAA,KAAAD,MAAA6B,EAAAA,GAAAA,CAEhBxB,KAAAA,MAAA;QACR,MAAAyB,eAAqB3B,OAAM0B,EAAAA,CAAI,KAAK7B,MAAK6B,EAAG;QAAC,OAEtC,MAAA;YACLC,aAAYC,WAAAA,CAAAA;QAAc;IAC3B,GACAzB,KAAAA;QAACH;QAAQH,MAAK6B,EAAG;KAAA,EAAC5B,CAAAA,CAAAA,EAAAA,GAAAE,QAAAF,CAAAA,CAAA,CAAA,CAAA,GAAAD,MAAA6B,EAAAA,EAAA5B,CAAAA,CAAAA,EAAAA,GAAAI,IAAAJ,CAAAA,CAAAA,EAAAA,GAAAK,EAAAA,IAAAA,CAAAD,KAAAJ,CAAAA,CAAA,CAAA,CAAA,EAAAK,KAAAL,CAAAA,CAAA,CAAA,CAAA,OANrBa,uaAAAA,EAAUT,IAMPC,EAAkB,GAEd;AAAI","debugId":null}},
    {"offset": {"line": 1587, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/utils/index.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.block-offset-to-block-selection-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.block-offset-to-selection-point.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.block-offsets-to-selection.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.child-selection-point-to-block-offset.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.is-equal-selections.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.merge-text-blocks.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.reverse-selection.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.selection-point-to-block-offset.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/utils/util.split-text-block.ts"],"sourcesContent":["import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function blockOffsetToBlockSelectionPoint({\n  context,\n  blockOffset,\n}: {\n  context: Pick<EditorContext, 'value'>\n  blockOffset: BlockOffset\n}): EditorSelectionPoint | undefined {\n  let selectionPoint: EditorSelectionPoint | undefined\n\n  for (const block of context.value) {\n    if (block._key === blockOffset.path[0]._key) {\n      selectionPoint = {\n        path: [{_key: block._key}],\n        offset: blockOffset.offset,\n      }\n      break\n    }\n  }\n\n  return selectionPoint\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {blockOffsetToSpanSelectionPoint} from './util.block-offset'\nimport {blockOffsetToBlockSelectionPoint} from './util.block-offset-to-block-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetToSelectionPoint({\n  context,\n  blockOffset,\n  direction,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}): EditorSelectionPoint | undefined {\n  const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context,\n    blockOffset,\n    direction,\n  })\n\n  if (!spanSelectionPoint) {\n    return blockOffsetToBlockSelectionPoint({\n      context,\n      blockOffset,\n    })\n  }\n\n  return spanSelectionPoint\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {blockOffsetToSelectionPoint} from './util.block-offset-to-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetsToSelection({\n  context,\n  offsets,\n  backward,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  offsets: {anchor: BlockOffset; focus: BlockOffset}\n  backward?: boolean\n}): EditorSelection {\n  const anchor = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.anchor,\n    direction: backward ? 'backward' : 'forward',\n  })\n  const focus = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.focus,\n    direction: backward ? 'forward' : 'backward',\n  })\n\n  if (!anchor || !focus) {\n    return null\n  }\n\n  return {\n    anchor,\n    focus,\n    backward,\n  }\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * @public\n */\nexport function childSelectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n  const childKey = getChildKeyFromSelectionPoint(selectionPoint)\n\n  if (!blockKey || !childKey) {\n    return undefined\n  }\n\n  for (const block of context.value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (child._key === childKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      if (isSpan(context, child)) {\n        offset += child.text.length\n      }\n    }\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from './util.is-equal-selection-points'\n\n/**\n * @public\n */\nexport function isEqualSelections(a: EditorSelection, b: EditorSelection) {\n  if (!a && !b) {\n    return true\n  }\n\n  if (!a || !b) {\n    return false\n  }\n\n  return (\n    isEqualSelectionPoints(a.anchor, b.anchor) &&\n    isEqualSelectionPoints(a.focus, b.focus)\n  )\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {parseBlock} from './parse-blocks'\n\n/**\n * @beta\n */\nexport function mergeTextBlocks({\n  context,\n  targetBlock,\n  incomingBlock,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  targetBlock: PortableTextTextBlock\n  incomingBlock: PortableTextTextBlock\n}) {\n  const parsedIncomingBlock = parseBlock({\n    context,\n    block: incomingBlock,\n    options: {\n      normalize: false,\n      removeUnusedMarkDefs: true,\n      validateFields: false,\n    },\n  })\n\n  if (!parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock)) {\n    return targetBlock\n  }\n\n  return {\n    ...targetBlock,\n    children: [...targetBlock.children, ...parsedIncomingBlock.children],\n    markDefs: [\n      ...(targetBlock.markDefs ?? []),\n      ...(parsedIncomingBlock.markDefs ?? []),\n    ],\n  }\n}\n","import type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport function reverseSelection<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n>(selection: TEditorSelection): TEditorSelection {\n  if (!selection) {\n    return selection\n  }\n\n  if (selection.backward) {\n    return {\n      anchor: selection.focus,\n      focus: selection.anchor,\n      backward: false,\n    } as TEditorSelection\n  }\n\n  return {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: true,\n  } as TEditorSelection\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {childSelectionPointToBlockOffset} from './util.child-selection-point-to-block-offset'\nimport {getBlockKeyFromSelectionPoint} from './util.selection-point'\n\n/**\n * @public\n */\nexport function selectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n\n  if (selectionPoint.path.length === 1 && blockKey !== undefined) {\n    return {\n      path: [{_key: blockKey}],\n      offset: selectionPoint.offset,\n    }\n  }\n\n  return childSelectionPointToBlockOffset({\n    context,\n    selectionPoint,\n  })\n}\n","import {isSpan, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {sliceTextBlock} from './util.slice-text-block'\n\n/**\n * @beta\n */\nexport function splitTextBlock({\n  context,\n  block,\n  point,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: PortableTextTextBlock\n  point: EditorSelectionPoint\n}): {before: PortableTextTextBlock; after: PortableTextTextBlock} | undefined {\n  const firstChild = block.children.at(0)\n  const lastChild = block.children.at(block.children.length - 1)\n\n  if (!firstChild || !lastChild) {\n    return undefined\n  }\n\n  const before = sliceTextBlock({\n    context: {\n      schema: context.schema,\n      selection: {\n        anchor: {\n          path: [{_key: block._key}, 'children', {_key: firstChild._key}],\n          offset: 0,\n        },\n        focus: point,\n      },\n    },\n    block,\n  })\n  const after = sliceTextBlock({\n    context: {\n      schema: context.schema,\n      selection: {\n        anchor: point,\n        focus: {\n          path: [{_key: block._key}, 'children', {_key: lastChild._key}],\n          offset: isSpan(context, lastChild) ? lastChild.text.length : 0,\n        },\n      },\n    },\n    block,\n  })\n\n  return {before, after}\n}\n"],"names":["blockOffsetToBlockSelectionPoint","context","blockOffset","selectionPoint","block","value","_key","path","offset","blockOffsetToSelectionPoint","direction","blockOffsetToSpanSelectionPoint","blockOffsetsToSelection","offsets","backward","anchor","focus","childSelectionPointToBlockOffset","blockKey","getBlockKeyFromSelectionPoint","childKey","getChildKeyFromSelectionPoint","isTextBlock","child","children","isSpan","text","length","isEqualSelections","a","b","isEqualSelectionPoints","mergeTextBlocks","targetBlock","incomingBlock","parsedIncomingBlock","parseBlock","options","normalize","removeUnusedMarkDefs","validateFields","markDefs","reverseSelection","selection","selectionPointToBlockOffset","undefined","splitTextBlock","point","firstChild","at","lastChild","before","sliceTextBlock","schema","after"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1779, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+editor@4.2.2_@portabletext+sanity-bridge@2.0.0_@types+react@19.2.2__@type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/@portabletext/editor/lib/selectors/index.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-anchor-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-anchor-text-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-anchor-child.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-anchor-span.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-block-offsets.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-first-block.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-next-inline-objects.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-previous-inline-objects.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-selection.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-text-after.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-text-before.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.get-value.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-point-after-selection.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Beditor%404.2.2_%40portabletext%2Bsanity-bridge%402.0.0_%40types%2Breact%4019.2.2__%40type_9e5c4a470ba434d0a1e40b5f8b2f25a3/node_modules/%40portabletext/editor/src/selectors/selector.is-point-before-selection.ts"],"sourcesContent":["import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getAnchorBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = getBlockKeyFromSelectionPoint(snapshot.context.selection.anchor)\n  const index = key ? snapshot.blockIndexMap.get(key) : undefined\n  const node =\n    index !== undefined ? snapshot.context.value.at(index) : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getAnchorBlock} from './selector.get-anchor-block'\n\n/**\n * @public\n */\nexport const getAnchorTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const anchorBlock = getAnchorBlock(snapshot)\n\n  return anchorBlock && isTextBlock(snapshot.context, anchorBlock.node)\n    ? {node: anchorBlock.node, path: anchorBlock.path}\n    : undefined\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getAnchorTextBlock} from './selector.get-anchor-text-block'\n\n/**\n * @public\n */\nexport const getAnchorChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const anchorBlock = getAnchorTextBlock(snapshot)\n\n  if (!anchorBlock) {\n    return undefined\n  }\n\n  const key = getChildKeyFromSelectionPoint(snapshot.context.selection.anchor)\n\n  const node = key\n    ? anchorBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...anchorBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import {isSpan, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getAnchorChild} from './selector.get-anchor-child'\n\n/**\n * @public\n */\nexport const getAnchorSpan: EditorSelector<\n  {node: PortableTextSpan; path: ChildPath} | undefined\n> = (snapshot) => {\n  const anchorChild = getAnchorChild(snapshot)\n\n  return anchorChild && isSpan(snapshot.context, anchorChild.node)\n    ? {node: anchorChild.node, path: anchorChild.path}\n    : undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getBlockOffsets: EditorSelector<\n  {start: BlockOffset; end: BlockOffset} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionStartPoint || !selectionEndPoint) {\n    return undefined\n  }\n\n  const start = spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionStartPoint,\n  })\n  const end = spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionEndPoint,\n  })\n\n  return start && end ? {start, end} : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObjects: EditorSelector<\n  Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeyedSegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return []\n  }\n\n  let endPointChildFound = false\n  const inlineObjects: Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }> = []\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObjects.push({\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      })\n      break\n    }\n  }\n\n  return inlineObjects\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousInlineObjects: EditorSelector<\n  Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeyedSegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return []\n  }\n\n  const inlineObjects: Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }> = []\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObjects.push({\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      })\n    }\n  }\n\n  return inlineObjects\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelection: EditorSelector<EditorSelection> = (snapshot) => {\n  return snapshot.context.selection\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusBlock} from './selector.get-focus-block'\nimport {getSelectionText} from './selector.get-selection-text'\n\n/**\n * @public\n */\nexport const getBlockTextAfter: EditorSelector<string> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return ''\n  }\n\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const block = getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n\n  if (!block) {\n    return ''\n  }\n\n  const endOfBlock = getBlockEndPoint({\n    context: snapshot.context,\n    block,\n  })\n\n  return getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endOfBlock,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusBlock} from './selector.get-focus-block'\nimport {getSelectionText} from './selector.get-selection-text'\n\n/**\n * @public\n */\nexport const getBlockTextBefore: EditorSelector<string> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return ''\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const block = getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n\n  if (!block) {\n    return ''\n  }\n\n  const startOfBlock = getBlockStartPoint({\n    context: snapshot.context,\n    block,\n  })\n\n  return getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startOfBlock,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return snapshot.context.value\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {comparePoints} from '../utils/util.compare-points'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n    return comparePoints(snapshot, point, endPoint) === 1\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {comparePoints} from '../utils/util.compare-points'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n    return comparePoints(snapshot, point, startPoint) === -1\n  }\n}\n"],"names":["getAnchorBlock","snapshot","context","selection","key","getBlockKeyFromSelectionPoint","anchor","index","blockIndexMap","get","undefined","node","value","at","path","_key","getAnchorTextBlock","anchorBlock","isTextBlock","getAnchorChild","getChildKeyFromSelectionPoint","children","find","span","getAnchorSpan","anchorChild","isSpan","getBlockOffsets","selectionStartPoint","getSelectionStartPoint","selectionEndPoint","getSelectionEndPoint","start","spanSelectionPointToBlockOffset","selectionPoint","end","getFirstBlock","getNextInlineObjects","focusTextBlock","getFocusTextBlock","selectionEndPointChildKey","isKeyedSegment","endPointChildFound","inlineObjects","child","push","getPreviousInlineObjects","selectionStartPointChildKey","getSelection","getBlockTextAfter","endPoint","block","getFocusBlock","focus","endOfBlock","getBlockEndPoint","getSelectionText","getBlockTextBefore","startPoint","startOfBlock","getBlockStartPoint","getValue","isPointAfterSelection","point","comparePoints","isPointBeforeSelection"],"mappings":"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","debugId":null}}]
}