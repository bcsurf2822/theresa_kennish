{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+block-tools@5.0.0_@types+react@19.2.2_debug@4.4.3/node_modules/@portabletext/block-tools/lib/_chunks-es/helpers.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/util/resolveJsType.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/equality.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/types.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/flatten-nested-blocks.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/constants.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/helpers.ts"],"sourcesContent":["const objectToString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (objectToString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","export function isEqualMarks(\n  a: Array<string> | undefined,\n  b: Array<string> | undefined,\n): boolean {\n  if (!a || !b) {\n    return a === b\n  }\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * More or less copied from Remeda (https://github.com/remeda/remeda/blob/main/packages/remeda/src/isDeepEqual.ts)\n */\nexport function isDeepEqual<A, B>(data: A, other: B) {\n  return isDeepEqualImplementation(data, other)\n}\n\nfunction isDeepEqualImplementation<T>(data: unknown, other: T): data is T {\n  if (data === other) {\n    return true\n  }\n\n  if (Object.is(data, other)) {\n    // We want to ignore the slight differences between `===` and `Object.is` as\n    // both of them largely define equality from a semantic point-of-view.\n    return true\n  }\n\n  if (typeof data !== 'object' || typeof other !== 'object') {\n    return false\n  }\n\n  if (data === null || other === null) {\n    return false\n  }\n\n  if (Object.getPrototypeOf(data) !== Object.getPrototypeOf(other)) {\n    // If the objects don't share a prototype it's unlikely that they are\n    // semantically equal. It is technically possible to build 2 prototypes that\n    // act the same but are not equal (at the reference level, checked via\n    // `===`) and then create 2 objects that are equal although we would fail on\n    // them. Because this is so unlikely, the optimization we gain here for the\n    // rest of the function by assuming that `other` is of the same type as\n    // `data` is more than worth it.\n    return false\n  }\n\n  if (Array.isArray(data)) {\n    return isDeepEqualArrays(data, other as unknown as ReadonlyArray<unknown>)\n  }\n\n  if (data instanceof Map) {\n    return isDeepEqualMaps(data, other as unknown as Map<unknown, unknown>)\n  }\n\n  if (data instanceof Set) {\n    return isDeepEqualSets(data, other as unknown as Set<unknown>)\n  }\n\n  if (data instanceof Date) {\n    return data.getTime() === (other as unknown as Date).getTime()\n  }\n\n  if (data instanceof RegExp) {\n    return data.toString() === (other as unknown as RegExp).toString()\n  }\n\n  // At this point we only know that the 2 objects share a prototype and are not\n  // any of the previous types. They could be plain objects (Object.prototype),\n  // they could be classes, they could be other built-ins, or they could be\n  // something weird. We assume that comparing values by keys is enough to judge\n  // their equality.\n\n  if (Object.keys(data).length !== Object.keys(other).length) {\n    return false\n  }\n\n  for (const [key, value] of Object.entries(data)) {\n    if (!(key in other)) {\n      return false\n    }\n\n    if (\n      !isDeepEqualImplementation(\n        value,\n        // @ts-expect-error [ts7053] - We already checked that `other` has `key`\n        other[key],\n      )\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualArrays(\n  data: ReadonlyArray<unknown>,\n  other: ReadonlyArray<unknown>,\n): boolean {\n  if (data.length !== other.length) {\n    return false\n  }\n\n  for (const [index, item] of data.entries()) {\n    if (!isDeepEqualImplementation(item, other[index])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualMaps(\n  data: ReadonlyMap<unknown, unknown>,\n  other: ReadonlyMap<unknown, unknown>,\n): boolean {\n  if (data.size !== other.size) {\n    return false\n  }\n\n  for (const [key, value] of data.entries()) {\n    if (!other.has(key)) {\n      return false\n    }\n\n    if (!isDeepEqualImplementation(value, other.get(key))) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualSets(\n  data: ReadonlySet<unknown>,\n  other: ReadonlySet<unknown>,\n): boolean {\n  if (data.size !== other.size) {\n    return false\n  }\n\n  // To ensure we only count each item once we need to \"remember\" which items of\n  // the other set we've already matched against. We do this by creating a copy\n  // of the other set and removing items from it as we find them in the data\n  // set.\n  const otherCopy = [...other]\n\n  for (const dataItem of data) {\n    let isFound = false\n\n    for (const [index, otherItem] of otherCopy.entries()) {\n      if (isDeepEqualImplementation(dataItem, otherItem)) {\n        isFound = true\n        otherCopy.splice(index, 1)\n        break\n      }\n    }\n\n    if (!isFound) {\n      return false\n    }\n  }\n\n  return true\n}\n","import type {PortableTextObject} from '@portabletext/schema'\nimport type {SchemaMatchers} from './schema-matchers'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  _type: string\n  _key?: string\n}\n\n/**\n * @public\n */\nexport interface ArbitraryTypedObject extends TypedObject {\n  [key: string]: unknown\n}\n\nexport function isArbitraryTypedObject(\n  object: unknown,\n): object is ArbitraryTypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\nexport interface MinimalSpan {\n  _type: 'span'\n  _key?: string\n  text: string\n  marks?: string[]\n}\n\nexport interface MinimalBlock extends TypedObject {\n  _type: 'block'\n  children: TypedObject[]\n  markDefs?: TypedObject[]\n  style?: string\n  level?: number\n  listItem?: string\n}\n\nexport interface PlaceholderDecorator {\n  _type: '__decorator'\n  name: string\n  children: TypedObject[]\n}\n\nexport interface PlaceholderAnnotation {\n  _type: '__annotation'\n  markDef: PortableTextObject\n  children: TypedObject[]\n}\n\n/**\n * @public\n */\nexport type HtmlParser = (html: string) => Document\n\n/**\n * @public\n */\nexport type WhiteSpacePasteMode = 'preserve' | 'remove' | 'normalize'\n\n/**\n * @public\n */\nexport interface HtmlDeserializerOptions {\n  keyGenerator?: () => string\n  rules?: DeserializerRule[]\n  parseHtml?: HtmlParser\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n  /**\n   * Custom schema matchers to use when deserializing HTML to Portable Text.\n   * @beta\n   */\n  matchers?: SchemaMatchers\n}\n\nexport interface HtmlPreprocessorOptions {\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n}\n\n/**\n * @public\n */\nexport interface DeserializerRule {\n  deserialize: (\n    el: Node,\n    next: (\n      elements: Node | Node[] | NodeList,\n    ) => TypedObject | TypedObject[] | undefined,\n    createBlock: (props: ArbitraryTypedObject) => {\n      _type: string\n      block: ArbitraryTypedObject\n    },\n  ) => TypedObject | TypedObject[] | undefined\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isDeepEqual} from '../equality'\nimport {\n  isArbitraryTypedObject,\n  type ArbitraryTypedObject,\n  type TypedObject,\n} from '../types'\n\nexport function flattenNestedBlocks(\n  context: {\n    schema: Schema\n  },\n  blocks: Array<ArbitraryTypedObject>,\n): TypedObject[] {\n  const flattened = blocks.flatMap((block) => {\n    if (isBlockContainer(block)) {\n      return flattenNestedBlocks(context, [block.block])\n    }\n\n    if (isTextBlock(context, block)) {\n      const hasBlockObjects = block.children.some((child) => {\n        const knownBlockObject = context.schema.blockObjects.some(\n          (blockObject) => blockObject.name === child._type,\n        )\n        return knownBlockObject\n      })\n      const hasBlocks = block.children.some(\n        (child) => child._type === '__block' || child._type === 'block',\n      )\n\n      if (hasBlockObjects || hasBlocks) {\n        const splitChildren = getSplitChildren(context, block)\n\n        if (\n          splitChildren.length === 1 &&\n          splitChildren[0].type === 'children' &&\n          isDeepEqual(splitChildren[0].children, block.children)\n        ) {\n          return [block]\n        }\n\n        return splitChildren.flatMap((slice) => {\n          if (slice.type === 'block object') {\n            return [slice.block]\n          }\n\n          if (slice.type === 'block') {\n            return flattenNestedBlocks(context, [\n              slice.block as ArbitraryTypedObject,\n            ])\n          }\n\n          if (slice.children.length > 0) {\n            if (\n              slice.children.every(\n                (child) => isSpan(context, child) && child.text.trim() === '',\n              )\n            ) {\n              return []\n            }\n\n            return flattenNestedBlocks(context, [\n              {\n                ...block,\n                children: slice.children,\n              },\n            ])\n          }\n\n          return []\n        })\n      }\n\n      return [block]\n    }\n\n    return [block]\n  })\n\n  return flattened\n}\n\nfunction isBlockContainer(\n  block: ArbitraryTypedObject,\n): block is BlockContainer {\n  return block._type === '__block' && isArbitraryTypedObject(block.block)\n}\n\ntype BlockContainer = {\n  _type: '__block'\n  block: ArbitraryTypedObject\n}\n\nfunction getSplitChildren(\n  context: {schema: Schema},\n  block: PortableTextTextBlock,\n) {\n  return block.children.reduce(\n    (slices, child) => {\n      const knownInlineObject = context.schema.inlineObjects.some(\n        (inlineObject) => inlineObject.name === child._type,\n      )\n      const knownBlockObject = context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type,\n      )\n\n      const lastSlice = slices.pop()\n\n      if (!isSpan(context, child) && !knownInlineObject) {\n        if (knownBlockObject) {\n          return [\n            ...slices,\n            ...(lastSlice ? [lastSlice] : []),\n            {type: 'block object' as const, block: child},\n          ]\n        }\n      }\n\n      if (child._type === '__block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {\n            type: 'block object' as const,\n            block: (child as any).block,\n          },\n        ]\n      }\n\n      if (child._type === 'block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {type: 'block' as const, block: child},\n        ]\n      }\n\n      if (lastSlice) {\n        if (lastSlice.type === 'children') {\n          return [\n            ...slices,\n            {\n              type: 'children' as const,\n              children: [...lastSlice.children, child],\n            },\n          ]\n        }\n      }\n\n      return [\n        ...slices,\n        ...(lastSlice ? [lastSlice] : []),\n        {type: 'children' as const, children: [child]},\n      ]\n    },\n    [] as Array<\n      | {\n          type: 'children'\n          children: Array<PortableTextSpan | PortableTextObject>\n        }\n      | {type: 'block object'; block: PortableTextObject}\n      | {type: 'block'; block: PortableTextBlock}\n    >,\n  )\n}\n","export interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<\n  string,\n  {object: null} | undefined\n> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = [\n  ...new Set(\n    Object.values(ELEMENT_MAP)\n      .filter((tag): tag is PartialBlock => 'style' in tag)\n      .map((tag) => tag.style),\n  ),\n]\n\nexport const DEFAULT_SUPPORTED_DECORATORS = [\n  ...new Set(Object.values(HTML_DECORATOR_TAGS)),\n]\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","import type {Schema} from '@portabletext/schema'\nimport {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport {DEFAULT_BLOCK} from '../constants'\nimport type {\n  ArbitraryTypedObject,\n  HtmlParser,\n  MinimalBlock,\n  MinimalSpan,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {resolveJsType} from '../util/resolveJsType'\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nexport function ensureRootIsBlocks(\n  schema: Schema,\n  objects: Array<ArbitraryTypedObject>,\n): ArbitraryTypedObject[] {\n  return objects.reduce((blocks, node, i, original) => {\n    if (node._type === 'block') {\n      blocks.push(node)\n      return blocks\n    }\n\n    if (node._type === '__block') {\n      blocks.push((node as any).block)\n      return blocks\n    }\n\n    const lastBlock = blocks[blocks.length - 1]\n    if (\n      i > 0 &&\n      !isTextBlock({schema}, original[i - 1]) &&\n      isTextBlock({schema}, lastBlock)\n    ) {\n      lastBlock.children.push(node as PortableTextObject)\n      return blocks\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    blocks.push(block)\n    return blocks\n  }, [] as ArbitraryTypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) === '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(\n  node: TypedObject,\n): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(\n  node: TypedObject,\n): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 354, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/code/cedesigns/theresa_kennish/node_modules/.pnpm/@portabletext+block-tools@5.0.0_@types+react@19.2.2_debug@4.4.3/node_modules/@portabletext/block-tools/lib/index.js","sources":["file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/node_modules/.pnpm/%40vercel%2Bstega%401.0.0/node_modules/%40vercel/stega/dist/index.mjs","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/util/randomKey.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/asserters.word-online.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/preprocessor.word-online.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/xpathResult.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.gdocs.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.html.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.notion.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.whitespace.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/preprocessor.word.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/index.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/word-online/rules.word-online.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.gdocs.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.whitespace-text-node.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.html.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.notion.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/rules.word.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/index.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/trim-whitespace.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/index.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/util/normalizeBlock.ts","file:///Users/benjamincorbett/code/cedesigns/theresa_kennish/node_modules/.pnpm/%40portabletext%2Bblock-tools%405.0.0_%40types%2Breact%4019.2.2_debug%404.4.3/node_modules/%40portabletext/block-tools/src/index.ts"],"sourcesContent":["var l={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},d={0:8203,1:8204,2:8205,3:65279},a={0:String.fromCodePoint(d[0]),1:String.fromCodePoint(d[1]),2:String.fromCodePoint(d[2]),3:String.fromCodePoint(d[3])},p=new Array(4).fill(String.fromCodePoint(d[0])).join(\"\"),m=String.fromCharCode(0);function A(t){let e=JSON.stringify(t),r=new TextEncoder().encode(e),n=\"\";for(let i=0;i<r.length;i++){let c=r[i];n+=a[c>>6&3]+a[c>>4&3]+a[c>>2&3]+a[c&3]}return p+n}function C(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(i=>String.fromCodePoint(l[i])).join(\"\")}).join(\"\")}function h(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:!!Date.parse(t)}function S(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function b(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(h(t)||S(t))?t:`${t}${A(e)}`}var g=Object.fromEntries(Object.entries(a).map(t=>[t[1],+t[0]])),T=Object.fromEntries(Object.entries(l).map(t=>t.reverse())),_=`${Object.values(l).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,u=new RegExp(`[${_}]{4,}`,\"gu\");function X(t){let e=t.match(u);if(e)return x(e[0],!0)[0]}function w(t){let e=t.match(u);if(e)return e.map(r=>x(r)).flat()}function x(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(p))return I(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=r.slice(4),i=new Uint8Array(n.length/4);for(let o=0;o<i.length;o++)i[o]=g[n[o*4]]<<6|g[n[o*4+1]]<<4|g[n[o*4+2]]<<2|g[n[o*4+3]];let c=new TextDecoder().decode(i);if(e){let o=c.indexOf(m);return o===-1&&(o=c.length),[JSON.parse(c.slice(0,o))]}return c.split(m).filter(Boolean).map(o=>JSON.parse(o))}function I(t,e){var o;let r=[];for(let s=t.length*.5;s--;){let f=`${T[t[s*2].codePointAt(0)]}${T[t[s*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(f,16)))}let n=[],i=[r.join(\"\")],c=10;for(;i.length;){let s=i.shift();try{if(n.push(JSON.parse(s)),e)return n}catch(f){if(!c--)throw f;let E=+((o=f.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:o[1]);if(!E)throw f;i.unshift(s.substring(0,E),s.substring(E))}}return n}function D(t){var e;return{cleaned:t.replace(u,\"\"),encoded:((e=t.match(u))==null?void 0:e[0])||\"\"}}function M(t){return t&&JSON.parse(D(JSON.stringify(t)).cleaned)}export{u as VERCEL_STEGA_REGEX,C as legacyStegaEncode,M as vercelStegaClean,b as vercelStegaCombine,X as vercelStegaDecode,w as vercelStegaDecodeAll,A as vercelStegaEncode,D as vercelStegaSplit};\n","export function keyGenerator() {\n  return randomKey(12)\n}\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).slice(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import {isElement, tagName} from '../helpers'\n\nexport function isWordOnlineHtml(html: string): boolean {\n  return (\n    /class=\"(?:TextRun|NormalTextRun)[^\"]*SCXW\\d+[^\"]*BCX\\d+/.test(html) ||\n    /class=\"EOP[^\"]*SCXW\\d+/.test(html)\n  )\n}\n\nexport function isWordOnlineTextRun(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('TextRun') && !el.classList.contains('EOP')\n}\n\n/**\n * Identifies the inner text holder spans in Word Online's nested structure.\n * Word Online uses: <span class=\"TextRun\"><span class=\"NormalTextRun\">text</span></span>\n * This function matches the inner span where actual text content lives.\n * Use this to find the text-bearing children within a TextRun container.\n */\nexport function isNormalTextRun(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('NormalTextRun')\n}\n\n/**\n * Identifies the outer container spans in Word Online's nested structure.\n * Word Online uses: <span class=\"TextRun\"><span class=\"NormalTextRun\">text</span></span>\n * This function matches the outer span that holds formatting and contains NormalTextRun children.\n * Use this to find the top-level containers, then search within for NormalTextRun spans.\n * Note: Excludes spans that also have \"NormalTextRun\" or \"EOP\" classes.\n */\nexport function isTextRunSpan(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return (\n    el.classList.contains('TextRun') &&\n    !el.classList.contains('NormalTextRun') &&\n    !el.classList.contains('EOP')\n  )\n}\n\nexport function isEmptyOutlineElement(el: Element): boolean {\n  if (!isElement(el)) {\n    return false\n  }\n\n  if (!el.classList.contains('OutlineElement')) {\n    return false\n  }\n\n  return el.textContent.trim() === ''\n}\n\nexport function isFindHit(el: Node): boolean {\n  if (!isElement(el) || tagName(el) !== 'span') {\n    return false\n  }\n\n  return el.classList.contains('FindHit')\n}\n\nexport function isInHeading(el: Node): boolean {\n  let current: Node | null = el\n\n  while (current) {\n    if (isElement(current)) {\n      if (\n        tagName(current) === 'word-online-block' &&\n        /^heading \\d$/.test(current.getAttribute('data-parastyle') ?? '')\n      ) {\n        return true\n      }\n    }\n\n    current = current.parentNode\n  }\n\n  return false\n}\n\nexport function isInBlockquote(el: Node): boolean {\n  let current: Node | null = el\n\n  while (current) {\n    if (isElement(current)) {\n      if (\n        tagName(current) === 'word-online-block' &&\n        current.getAttribute('data-parastyle') === 'Quote'\n      ) {\n        return true\n      }\n    }\n\n    current = current.parentNode\n  }\n\n  return false\n}\n\n/**********************\n * Formatting asserters\n **********************/\n\nexport function hasStrongFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('MacChromeBold') ||\n    /font-weight\\s*:\\s*bold/.test(style)\n  )\n}\n\nexport function hasEmphasisFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return /font-style\\s*:\\s*italic/.test(style)\n}\n\nexport function hasUnderlineFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('Underlined') ||\n    /text-decoration\\s*:\\s*underline/.test(style)\n  )\n}\n\nexport function hasStrikethroughFormatting(el: Element): boolean {\n  const style = el.getAttribute('style') ?? ''\n\n  return (\n    el.classList.contains('Strikethrough') ||\n    /text-decoration\\s*:\\s*line-through/.test(style)\n  )\n}\n\nexport function hasFormatting(el: Element): boolean {\n  return (\n    hasStrongFormatting(el) ||\n    hasEmphasisFormatting(el) ||\n    hasUnderlineFormatting(el) ||\n    hasStrikethroughFormatting(el)\n  )\n}\n","import {isElement, tagName} from '../helpers'\nimport {\n  hasFormatting,\n  isNormalTextRun,\n  isTextRunSpan,\n  isWordOnlineHtml,\n} from './asserters.word-online'\n\nexport function preprocessWordOnline(html: string, doc: Document): Document {\n  if (!isWordOnlineHtml(html)) {\n    return doc\n  }\n\n  const paragraphs = Array.from(\n    doc.querySelectorAll('p.Paragraph[role=\"heading\"]'),\n  )\n\n  for (const paragraph of paragraphs) {\n    const ariaLevel = paragraph.getAttribute('aria-level')\n\n    if (ariaLevel) {\n      const wrapper = doc.createElement('word-online-block')\n\n      wrapper.setAttribute('data-parastyle', `heading ${ariaLevel}`)\n\n      const parent = paragraph.parentNode\n\n      if (parent) {\n        parent.insertBefore(wrapper, paragraph)\n\n        while (paragraph.firstChild) {\n          wrapper.appendChild(paragraph.firstChild)\n        }\n\n        parent.removeChild(paragraph)\n      }\n    }\n  }\n\n  // Group NormalTextRun spans with the same data-ccp-parastyle attribute\n  // This handles cases like blockquotes, headings where multiple spans should form one block\n  // Process from the body directly to handle DOM mutations\n  let child = doc.body.firstChild\n\n  while (child) {\n    const next = child.nextSibling\n\n    if (!isElement(child) || !tagName(child)?.includes('span')) {\n      child = next\n\n      continue\n    }\n\n    const paraStyle = getParaStyle(child)\n\n    if (!paraStyle) {\n      child = next\n\n      continue\n    }\n\n    // Found a span with paragraph style - collect all consecutive siblings with same style\n    const group: Element[] = [child]\n    let sibling = next\n\n    while (sibling) {\n      if (!isElement(sibling) || getParaStyle(sibling) !== paraStyle) {\n        break\n      }\n\n      group.push(sibling)\n      sibling = sibling.nextSibling\n    }\n\n    // Wrap the spans in a container\n    // Use a custom element name to avoid conflicts with HTML rules\n    const wrapper = doc.createElement('word-online-block')\n    wrapper.setAttribute('data-parastyle', paraStyle)\n\n    // Insert the wrapper before the first span\n    doc.body.insertBefore(wrapper, child)\n\n    // Move all grouped spans into the wrapper\n    for (const span of group) {\n      wrapper.appendChild(span)\n    }\n\n    // Continue with the sibling after the last grouped span\n    child = sibling\n  }\n\n  // Find all TextRun spans\n  const textRunSpans = Array.from(doc.body.querySelectorAll('span')).filter(\n    isTextRunSpan,\n  )\n\n  for (const textRunSpan of textRunSpans) {\n    // Find ALL NormalTextRun children (Word Online can have multiple per TextRun)\n    const normalTextRuns = Array.from(textRunSpan.childNodes).filter(\n      isNormalTextRun,\n    )\n\n    for (const normalTextRun of normalTextRuns) {\n      // Process ALL nested spans with whitespace in this NormalTextRun\n      // We need to process them in a loop since removing one might affect indices\n      let foundNestedSpan = true\n\n      while (foundNestedSpan) {\n        const children = Array.from(normalTextRun.childNodes)\n        const nestedSpanIndex = children.findIndex(\n          (node) =>\n            isElement(node) &&\n            tagName(node) === 'span' &&\n            node.textContent.trim() === '',\n        )\n\n        if (nestedSpanIndex === -1) {\n          foundNestedSpan = false\n          break\n        }\n\n        const nestedSpan = children.at(nestedSpanIndex)\n\n        if (!nestedSpan) {\n          foundNestedSpan = false\n          break\n        }\n\n        // Word Online uses non-breaking spaces, convert to regular spaces\n        const spaceText = nestedSpan.textContent?.replace(/\\u00a0/g, ' ') ?? ''\n\n        // Determine if the space is at the beginning or end BEFORE removing it\n        // Check if there are any text nodes before this position\n        const hasTextBefore = children\n          .slice(0, nestedSpanIndex)\n          .some((n) => n.nodeType === 3)\n        const isSpaceAtBeginning = !hasTextBefore\n\n        // Remove the nested span\n        normalTextRun.removeChild(nestedSpan)\n\n        if (isSpaceAtBeginning) {\n          // Space at the beginning - keep it at the beginning\n          const firstTextNode = Array.from(normalTextRun.childNodes).find(\n            (n) => n.nodeType === 3,\n          )\n\n          if (firstTextNode) {\n            firstTextNode.textContent =\n              spaceText + (firstTextNode.textContent || '')\n          } else {\n            // No text node exists, create one with the space\n            const spaceNode = doc.createTextNode(spaceText)\n            normalTextRun.insertBefore(spaceNode, normalTextRun.firstChild)\n          }\n        } else {\n          // Space at the end - check if we should move it to the next TextRun\n          // Only move if the formatting (marks) are different\n          const nextSibling = textRunSpan.nextSibling\n          const currentHasFormatting = hasFormatting(textRunSpan)\n\n          if (\n            nextSibling &&\n            isElement(nextSibling) &&\n            isTextRunSpan(nextSibling)\n          ) {\n            const nextHasFormatting = hasFormatting(nextSibling)\n\n            // If current has formatting but next doesn't, move space to the next span\n            // This makes semantic sense: \"**bar** baz\" or \"*bar* baz\" â†’ space should be outside the formatting\n            if (currentHasFormatting && !nextHasFormatting) {\n              const nextNormalTextRun = Array.from(nextSibling.childNodes).find(\n                isNormalTextRun,\n              )\n\n              if (nextNormalTextRun && isElement(nextNormalTextRun)) {\n                // Prepend space to the first text node of the next NormalTextRun\n                const firstChild = nextNormalTextRun.firstChild\n\n                if (firstChild && firstChild.nodeType === 3) {\n                  firstChild.textContent =\n                    spaceText + (firstChild.textContent ?? '')\n                } else {\n                  // No text node, insert a new one at the beginning\n                  const spaceNode = doc.createTextNode(spaceText)\n                  nextNormalTextRun.insertBefore(\n                    spaceNode,\n                    nextNormalTextRun.firstChild,\n                  )\n                }\n              }\n              // Don't add the space back to the current span - it's been moved\n            } else {\n              // Same formatting, keep the space in the current span\n              const lastTextNode = Array.from(normalTextRun.childNodes).find(\n                (n) => n.nodeType === 3,\n              )\n\n              if (lastTextNode) {\n                lastTextNode.textContent =\n                  (lastTextNode.textContent ?? '') + spaceText\n              } else {\n                // No text node exists, create one with the space\n                const spaceNode = doc.createTextNode(spaceText)\n                normalTextRun.appendChild(spaceNode)\n              }\n            }\n          } else {\n            // No next TextRun, keep the space at the end of this span's text\n            const lastTextNode = Array.from(normalTextRun.childNodes).find(\n              (n) => n.nodeType === 3,\n            )\n\n            if (lastTextNode) {\n              lastTextNode.textContent =\n                (lastTextNode.textContent ?? '') + spaceText\n            } else {\n              // No text node exists, create one with the space\n              const spaceNode = doc.createTextNode(spaceText)\n              normalTextRun.appendChild(spaceNode)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return doc\n}\n\n// Helper to get paragraph style from a span (either directly or from NormalTextRun child)\nfunction getParaStyle(element: Element): string | undefined {\n  // Check direct attribute first\n  const directStyle = element.getAttribute('data-ccp-parastyle')\n\n  if (directStyle) {\n    return directStyle\n  }\n\n  // Check if it's a TextRun with NormalTextRun children that have the attribute\n  if (tagName(element) === 'span' && element.classList.contains('TextRun')) {\n    const normalTextRuns = Array.from(\n      element.querySelectorAll('.NormalTextRun'),\n    )\n\n    if (normalTextRuns.length > 0) {\n      const firstStyle = normalTextRuns[0].getAttribute('data-ccp-parastyle')\n\n      // Verify all NormalTextRuns have the same style\n      if (\n        firstStyle &&\n        normalTextRuns.every(\n          (normalTextRun) =>\n            normalTextRun.getAttribute('data-ccp-parastyle') === firstStyle,\n        )\n      ) {\n        return firstStyle\n      }\n    }\n  }\n\n  return undefined\n}\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import {tagName} from '../helpers'\nimport {_XPathResult} from './xpathResult'\n\nexport function preprocessGDocs(_html: string, doc: Document): Document {\n  let gDocsRootOrSiblingNode = doc\n    .evaluate(\n      '//*[@id and contains(@id, \"docs-internal-guid\")]',\n      doc,\n      null,\n      _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n      null,\n    )\n    .iterateNext()\n\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === 'b'\n\n    // If this document isn't wrapped in a 'b' tag, then assume all siblings live on the root level\n    if (!isWrappedRootTag) {\n      gDocsRootOrSiblingNode = doc.body\n    }\n\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n\n      if (\n        elm?.parentElement === gDocsRootOrSiblingNode ||\n        (!isWrappedRootTag && elm.parentElement === doc.body)\n      ) {\n        elm?.setAttribute('data-is-root-node', 'true')\n        tagName(elm)\n      }\n\n      // Handle checkmark lists - The first child of a list item is an image with a checkmark, and the serializer\n      // expects the first child to be the text node\n      if (\n        tagName(elm) === 'li' &&\n        elm.firstChild &&\n        tagName(elm?.firstChild) === 'img'\n      ) {\n        elm.removeChild(elm.firstChild)\n      }\n    }\n\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    if (isWrappedRootTag) {\n      doc.body.firstElementChild?.replaceWith(\n        ...Array.from(gDocsRootOrSiblingNode.childNodes),\n      )\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport function preprocessHTML(_html: string, doc: Document): Document {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nexport function preprocessNotion(html: string, doc: Document): Document {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g\n\n  if (html.match(NOTION_REGEX)) {\n    // Tag every child with attribute 'is-notion' so that the Notion rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-notion', 'true')\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {PRESERVE_WHITESPACE_TAGS} from '../../constants'\nimport {_XPathResult} from './xpathResult'\n\n// Elements that only contain block-level children (not inline text content)\nconst BLOCK_CONTAINER_ELEMENTS = [\n  'body',\n  'table',\n  'tbody',\n  'thead',\n  'tfoot',\n  'tr',\n  'ul',\n  'ol',\n]\n\nexport function preprocessWhitespace(_: string, doc: Document): Document {\n  // Recursively process all nodes.\n  function processNode(node: Node) {\n    // If this is a text node and not inside a tag where whitespace should be preserved, process it.\n    if (\n      node.nodeType === _XPathResult.BOOLEAN_TYPE &&\n      !PRESERVE_WHITESPACE_TAGS.includes(\n        node.parentElement?.tagName.toLowerCase() || '',\n      )\n    ) {\n      const normalized =\n        node.textContent\n          ?.replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n          .replace(/[\\r\\n]+/g, ' ') || '' // Replace newlines with spaces\n      const parentTag = node.parentElement?.tagName.toLowerCase()\n\n      if (\n        parentTag &&\n        BLOCK_CONTAINER_ELEMENTS.includes(parentTag) &&\n        normalized.trim() === ''\n      ) {\n        // If parent is a block container and text is only whitespace, remove it\n        node.parentNode?.removeChild(node)\n      } else {\n        node.textContent = normalized\n      }\n    }\n    // Otherwise, if this node has children, process them.\n    else {\n      // Process children in reverse to handle removals safely\n      for (let i = node.childNodes.length - 1; i >= 0; i--) {\n        processNode(node.childNodes[i])\n      }\n    }\n  }\n\n  // Process all nodes starting from the root.\n  processNode(doc.body)\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX =\n  /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport function preprocessWord(html: string, doc: Document): Document {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = doc.createTextNode(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = doc.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import {preprocessWordOnline} from '../word-online/preprocessor.word-online'\nimport {preprocessGDocs} from './preprocessor.gdocs'\nimport {preprocessHTML} from './preprocessor.html'\nimport {preprocessNotion} from './preprocessor.notion'\nimport {preprocessWhitespace} from './preprocessor.whitespace'\nimport {preprocessWord} from './preprocessor.word'\n\nexport const preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessWordOnline,\n  preprocessGDocs,\n  preprocessHTML,\n]\n","import type {Schema} from '@portabletext/schema'\nimport {DEFAULT_SPAN, HTML_BLOCK_TAGS, HTML_HEADER_TAGS} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {\n  hasEmphasisFormatting,\n  hasStrikethroughFormatting,\n  hasStrongFormatting,\n  hasUnderlineFormatting,\n  isFindHit,\n  isInBlockquote,\n  isInHeading,\n  isNormalTextRun,\n  isWordOnlineTextRun,\n} from './asserters.word-online'\n\nfunction mapParaStyleToBlockStyle(schema: Schema, paraStyle: string) {\n  const blockStyleMap: Record<string, string> = {\n    'heading 1': 'h1',\n    'heading 2': 'h2',\n    'heading 3': 'h3',\n    'heading 4': 'h4',\n    'heading 5': 'h5',\n    'heading 6': 'h6',\n    'Quote': 'blockquote',\n  }\n\n  const blockStyle = blockStyleMap[paraStyle] ?? 'normal'\n\n  return schema.styles.find((style) => style.name === blockStyle)?.name\n}\n\nexport function createWordOnlineRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    // Image rule - handles bare Word Online <img> tags with WACImage class\n    {\n      deserialize(el) {\n        if (!isElement(el) || tagName(el) !== 'img') {\n          return undefined\n        }\n\n        // Handle className which might be a string or SVGAnimatedString\n        const classNameRaw = el.className\n        let className = ''\n        if (typeof classNameRaw === 'string') {\n          className = classNameRaw\n        } else if (classNameRaw && typeof classNameRaw === 'object') {\n          // SVGAnimatedString has baseVal property\n          className = (classNameRaw as {baseVal?: string}).baseVal || ''\n        }\n\n        if (!className.includes('WACImage')) {\n          return undefined\n        }\n\n        const src = el.getAttribute('src') ?? undefined\n        const alt = el.getAttribute('alt') ?? undefined\n\n        const props = Object.fromEntries(\n          Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n        )\n\n        // Bare <img> tags are typically block-level, not inline\n        // They should be returned as block images\n        const image = options.matchers?.image?.({\n          context: {\n            schema: schema,\n            keyGenerator: options.keyGenerator ?? keyGenerator,\n          },\n          props: {\n            ...props,\n            ...(src ? {src} : {}),\n            ...(alt ? {alt} : {}),\n          },\n        })\n\n        if (image) {\n          return {\n            _type: '__block',\n            block: image,\n          }\n        }\n\n        return undefined\n      },\n    },\n    // Image rule - handles Word Online images wrapped in WACImageContainer\n    {\n      deserialize(el) {\n        if (!isElement(el)) {\n          return undefined\n        }\n\n        // Handle className which might be a string or SVGAnimatedString\n        const classNameRaw = el.className\n        let className = ''\n        if (typeof classNameRaw === 'string') {\n          className = classNameRaw\n        } else if (classNameRaw && typeof classNameRaw === 'object') {\n          // SVGAnimatedString has baseVal property\n          className = (classNameRaw as {baseVal?: string}).baseVal || ''\n        }\n        if (!className.includes('WACImageContainer')) {\n          return undefined\n        }\n\n        // Find the img element inside\n        const img = el.querySelector('img')\n        if (!img) {\n          return undefined\n        }\n\n        const src = img.getAttribute('src') ?? undefined\n        const alt = img.getAttribute('alt') ?? undefined\n\n        const props = Object.fromEntries(\n          Array.from(img.attributes).map((attr) => [attr.name, attr.value]),\n        )\n\n        // Determine if this should be an inline or block-level image\n        // Word Online inline images:\n        // 1. Siblings of TextRun spans (not wrapped in paragraphs)\n        // 2. Inside list items (should be inline relative to the list item)\n        const isInsideListItem = el.closest('li') !== null\n        const isInsideParagraph = el.closest('p') !== null\n\n        if (!isInsideParagraph || isInsideListItem) {\n          // Inline image (either not in a paragraph, or inside a list item)\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema: schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n        }\n\n        // Block-level image (or fallback if inline image not supported)\n        const image = options.matchers?.image?.({\n          context: {\n            schema: schema,\n            keyGenerator: options.keyGenerator ?? keyGenerator,\n          },\n          props: {\n            ...props,\n            ...(src ? {src} : {}),\n            ...(alt ? {alt} : {}),\n          },\n        })\n\n        if (image) {\n          return {\n            _type: '__block',\n            block: image,\n          }\n        }\n\n        return undefined\n      },\n    },\n    // List item rule - handles <li> elements with aria-level\n    {\n      deserialize(el, next) {\n        if (!isElement(el) || tagName(el) !== 'li') {\n          return undefined\n        }\n\n        const ariaLevel = el.getAttribute('data-aria-level')\n\n        if (!ariaLevel) {\n          return undefined\n        }\n\n        const listItem = tagName(el.parentNode) === 'ol' ? 'number' : 'bullet'\n\n        let childNodesToProcess = el.childNodes\n        let blockStyle = 'normal'\n\n        if (\n          el.childNodes.length === 1 &&\n          el.firstChild &&\n          isElement(el.firstChild)\n        ) {\n          const childTag = tagName(el.firstChild)\n\n          if (\n            childTag &&\n            (HTML_BLOCK_TAGS[childTag as keyof typeof HTML_BLOCK_TAGS] ||\n              HTML_HEADER_TAGS[childTag as keyof typeof HTML_HEADER_TAGS] ||\n              childTag === 'word-online-block')\n          ) {\n            // If it's a word-online-block, extract the style before skipping it\n            if (childTag === 'word-online-block') {\n              const paraStyle = el.firstChild.getAttribute('data-parastyle')\n              const foundBlockStyle = paraStyle\n                ? mapParaStyleToBlockStyle(schema, paraStyle)\n                : undefined\n\n              if (foundBlockStyle) {\n                blockStyle = foundBlockStyle\n              }\n            }\n\n            // Skip the block wrapper and process its children directly\n            childNodesToProcess = el.firstChild.childNodes\n          }\n        }\n\n        const children = next(childNodesToProcess)\n        let childArray = Array.isArray(children)\n          ? children\n          : [children].filter(Boolean)\n\n        // Clean up trailing empty or whitespace-only spans\n        // Word Online often adds trailing tabs/breaks and extra spaces in list items\n        while (childArray.length > 0) {\n          const lastChild = childArray[childArray.length - 1]\n\n          if (\n            lastChild &&\n            typeof lastChild === 'object' &&\n            'text' in lastChild\n          ) {\n            const text = (lastChild.text as string).trimEnd()\n            if (text === '') {\n              // Remove empty span\n              childArray = childArray.slice(0, -1)\n            } else if (text !== lastChild.text) {\n              // Update with trimmed text\n              lastChild.text = text\n              break\n            } else {\n              break\n            }\n          } else {\n            break\n          }\n        }\n\n        return {\n          _type: schema.block.name,\n          children: childArray,\n          markDefs: [],\n          style: blockStyle,\n          listItem,\n          level: parseInt(ariaLevel, 10),\n        }\n      },\n    },\n    // Block style rule - handles paragraph styles like Quote\n    // The preprocessor wraps grouped NormalTextRun spans in a word-online-block element\n    {\n      deserialize(el, next) {\n        if (!isElement(el)) {\n          return undefined\n        }\n\n        const paraStyle = el.getAttribute('data-parastyle')\n        const blockStyle = paraStyle\n          ? mapParaStyleToBlockStyle(schema, paraStyle)\n          : undefined\n\n        if (!blockStyle) {\n          return undefined\n        }\n\n        const children = next(el.childNodes)\n\n        return {\n          _type: schema.block.name,\n          style: blockStyle,\n          markDefs: [],\n          children: Array.isArray(children)\n            ? children\n            : children\n              ? [children]\n              : [],\n        }\n      },\n    },\n    // TextRun rule\n    {\n      deserialize(el) {\n        if (isWordOnlineTextRun(el)) {\n          if (!isElement(el)) {\n            return undefined\n          }\n\n          if (!el.textContent) {\n            return undefined\n          }\n\n          // Find ALL NormalTextRun and FindHit children and extract text from them\n          // (Word Online sometimes splits text across multiple spans)\n          // FindHit is used for search result highlighting\n          const textSpans = Array.from(el.childNodes).filter(\n            (node) => isNormalTextRun(node) || isFindHit(node),\n          )\n          const text = textSpans\n            .map((span) => (isElement(span) ? (span.textContent ?? '') : ''))\n            .join('')\n\n          if (!text) {\n            return undefined\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as Array<string>,\n            text,\n          }\n\n          if (hasStrongFormatting(el)) {\n            span.marks.push('strong')\n          }\n\n          // Don't add italic mark if we're in a heading or blockquote (it's part of their default style)\n          if (\n            hasEmphasisFormatting(el) &&\n            !isInHeading(el) &&\n            !isInBlockquote(el)\n          ) {\n            span.marks.push('em')\n          }\n\n          // Add underline mark if the element has explicit underline formatting\n          // Word Online always adds underline to links, so we need to distinguish between:\n          // 1. Default link underline (skip)\n          // 2. Explicit user underline that includes the link (add)\n          // We check: if the link is surrounded by underlined content, it's explicit user underline\n          if (hasUnderlineFormatting(el)) {\n            const isInsideLink =\n              isElement(el) &&\n              el.parentElement &&\n              tagName(el.parentElement) === 'a'\n\n            if (isInsideLink) {\n              // Check if there are underlined siblings of the link\n              const linkElement = el.parentElement\n              if (linkElement) {\n                const prevSibling = linkElement.previousSibling\n                const nextSibling = linkElement.nextSibling\n\n                // If either sibling is an underlined TextRun, the link is part of explicit underline\n                const hasPrevUnderline =\n                  prevSibling &&\n                  isElement(prevSibling) &&\n                  hasUnderlineFormatting(prevSibling)\n                const hasNextUnderline =\n                  nextSibling &&\n                  isElement(nextSibling) &&\n                  hasUnderlineFormatting(nextSibling)\n\n                if (hasPrevUnderline || hasNextUnderline) {\n                  span.marks.push('underline')\n                }\n                // Otherwise, it's just default link styling, don't add underline mark\n              }\n            } else {\n              // Not in a link, always add underline\n              span.marks.push('underline')\n            }\n          }\n\n          // Add strikethrough mark if the element has strikethrough formatting\n          if (hasStrikethroughFormatting(el)) {\n            span.marks.push('strike-through')\n          }\n\n          return span\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style\\s*:\\s*italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight\\s*:\\s*700/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  if (!isElement(el) || tagName(el.parentNode) === 'a') {\n    return false\n  }\n\n  const style = isElement(el) && el.getAttribute('style')\n\n  return /text-decoration\\s*:\\s*underline/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for strike-through in their html\n// allows for line-through regex to be more lineient to allow for other text-decoration before or after\nfunction isStrikethrough(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction isRootNode(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-root-node'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(schema: Schema, el: Node): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!schema.styles.some((style) => style.name === block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport function createGDocsRules(schema: Schema): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          if (!el.textContent) {\n            if (!el.previousSibling && !el.nextSibling) {\n              el.setAttribute('data-lonely-child', 'true')\n            }\n\n            return next(el.childNodes)\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isStrikethrough(el)) {\n            span.marks.push('strike-through')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(schema, el),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el.classList.contains('apple-interchange-newline')\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs inside empty paragraphs\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el?.parentNode?.textContent === ''\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs on the root\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          isRootNode(el)\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {tagName} from '../helpers'\n\nexport const whitespaceTextNodeRule: DeserializerRule = {\n  deserialize(node) {\n    return node.nodeName === '#text' && isWhitespaceTextNode(node)\n      ? {\n          ...DEFAULT_SPAN,\n          marks: [],\n          text: (node.textContent ?? '').replace(/\\s\\s+/g, ' '),\n        }\n      : undefined\n  },\n}\n\nfunction isWhitespaceTextNode(node: Node) {\n  const isValidWhiteSpace =\n    node.nodeType === 3 &&\n    (node.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') ===\n      ' ' &&\n    node.nextSibling &&\n    node.nextSibling.nodeType !== 3 &&\n    node.previousSibling &&\n    node.previousSibling.nodeType !== 3\n\n  return (\n    (isValidWhiteSpace || node.textContent !== ' ') &&\n    tagName(node.parentNode) !== 'body'\n  )\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_DECORATOR_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_SPAN_TAGS,\n  type PartialBlock,\n} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {whitespaceTextNodeRule} from './rules.whitespace-text-node'\n\nfunction resolveListItem(\n  schema: Schema,\n  listNodeTagName: string,\n): string | undefined {\n  if (\n    listNodeTagName === 'ul' &&\n    schema.lists.some((list) => list.name === 'bullet')\n  ) {\n    return 'bullet'\n  }\n  if (\n    listNodeTagName === 'ol' &&\n    schema.lists.some((list) => list.name === 'number')\n  ) {\n    return 'number'\n  }\n  return undefined\n}\n\nexport function createHTMLRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== 'pre') {\n          return undefined\n        }\n\n        const isCodeEnabled = schema.styles.some(\n          (style) => style.name === 'code',\n        )\n\n        return {\n          _type: 'block',\n          style: 'normal',\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? ['code'] : [],\n              text: el.textContent || '',\n            },\n          ],\n        }\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n        const nonBlockquoteBlocks = Object.keys(blocks)\n\n        const children: HTMLElement[] = []\n\n        el.childNodes.forEach((node, index) => {\n          if (!el.ownerDocument) {\n            return\n          }\n\n          if (\n            node.nodeType === 1 &&\n            nonBlockquoteBlocks.includes(\n              (node as Element).localName.toLowerCase(),\n            )\n          ) {\n            const span = el.ownerDocument.createElement('span')\n\n            const previousChild = children[children.length - 1]\n\n            if (\n              previousChild &&\n              previousChild.nodeType === 3 &&\n              previousChild.textContent?.trim()\n            ) {\n              // Only prepend line break if the previous node is a non-empty\n              // text node.\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n\n            if (index !== el.childNodes.length) {\n              // Only append line break if this is not the last child\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el.parentNode) === 'li') {\n          return next(el.childNodes)\n        }\n        const blockStyle = block.style\n        // If style is not supported, return a defaultBlockType\n        if (!schema.styles.some((style) => style.name === blockStyle)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        const parentTag = tagName(el.parentNode) || ''\n        if (\n          !listItem ||\n          !el.parentNode ||\n          !HTML_LIST_CONTAINER_TAGS[parentTag]\n        ) {\n          return undefined\n        }\n        const enabledListItem = resolveListItem(schema, parentTag)\n        // If the list item style is not supported, return a new default block\n        if (!enabledListItem) {\n          return block({_type: 'block', children: next(el.childNodes)})\n        }\n        listItem.listItem = enabledListItem\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (\n          !decorator ||\n          !schema.decorators.some(\n            (decoratorType) => decoratorType.name === decorator,\n          )\n        ) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'a') {\n          return undefined\n        }\n        const linkEnabled = schema.annotations.some(\n          (annotation) => annotation.name === 'link',\n        )\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        if (linkEnabled) {\n          return {\n            _type: '__annotation',\n            markDef: {\n              _key: options.keyGenerator\n                ? options.keyGenerator()\n                : keyGenerator(),\n              _type: 'link',\n              href: href,\n            },\n            children: next(el.childNodes),\n          }\n        }\n        return (\n          el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) &&\n          next(el.childNodes)\n        )\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (isElement(el) && (tagName(el) === 'td' || tagName(el) === 'th')) {\n          return {\n            ...DEFAULT_BLOCK,\n            children: next(el.childNodes),\n          }\n        }\n\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'img') {\n          const src = el.getAttribute('src') ?? undefined\n          const alt = el.getAttribute('alt') ?? undefined\n\n          const props = Object.fromEntries(\n            Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n          )\n\n          const ancestorOfLonelyChild =\n            el?.parentElement?.parentElement?.getAttribute('data-lonely-child')\n          const ancestorOfListItem = el.closest('li') !== null\n\n          if (ancestorOfLonelyChild && !ancestorOfListItem) {\n            const image = options.matchers?.image?.({\n              context: {\n                schema,\n                keyGenerator: options.keyGenerator ?? keyGenerator,\n              },\n              props: {\n                ...props,\n                ...(src ? {src} : {}),\n                ...(alt ? {alt} : {}),\n              },\n            })\n\n            if (image) {\n              return {\n                _type: '__block',\n                block: image,\n              }\n            }\n          }\n\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n\n          const image = options.matchers?.image?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (image) {\n            return {\n              _type: '__block',\n              block: image,\n            }\n          }\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 or 600 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return (\n    /font-weight:700/.test(style || '') || /font-weight:600/.test(style || '')\n  )\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration:underline/.test(style || '')\n}\n\n// Check for attribute given by the Notion preprocessor\nfunction isNotion(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-notion'))\n}\n\nexport function createNotionRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        // Notion normally exports semantic HTML. However, if you copy a single block, the formatting will be inline styles\n        // This handles a limited set of styles\n        if (isElement(el) && tagName(el) === 'span' && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  HTML_HEADER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'number' : 'bullet'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? Number.parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  if (!isElement(el)) {\n    return false\n  }\n\n  // Check for specific class names\n  if (el.className) {\n    if (\n      el.className === 'MsoListParagraphCxSpFirst' ||\n      el.className === 'MsoListParagraphCxSpMiddle' ||\n      el.className === 'MsoListParagraphCxSpLast'\n    ) {\n      return true\n    }\n  }\n\n  // Check for mso-list in style attribute\n  const style = el.getAttribute('style')\n  if (style && /mso-list:\\s*l\\d+\\s+level\\d+\\s+lfo\\d+/.test(style)) {\n    return true\n  }\n\n  return false\n}\n\nfunction getHeadingStyle(el: Node): string | undefined {\n  const tag = tagName(el)\n  if (tag && HTML_HEADER_TAGS[tag]) {\n    return HTML_HEADER_TAGS[tag]?.style\n  }\n  return undefined\n}\n\nexport function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n\n        // Handle list items (both paragraphs and headings)\n        if (\n          (tag === 'p' || HTML_HEADER_TAGS[tag || '']) &&\n          isWordListElement(el)\n        ) {\n          const headingStyle = getHeadingStyle(el)\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: headingStyle || BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {createWordOnlineRules} from '../word-online/rules.word-online'\nimport {createGDocsRules} from './rules.gdocs'\nimport {createHTMLRules} from './rules.html'\nimport {createNotionRules} from './rules.notion'\nimport {createWordRules} from './rules.word'\n\nexport function createRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createWordOnlineRules(schema, options),\n    ...createNotionRules(),\n    ...createGDocsRules(schema),\n    ...createHTMLRules(schema, options),\n  ]\n}\n","import {\n  isSpan,\n  isTextBlock,\n  type PortableTextTextBlock,\n  type Schema,\n} from '@portabletext/schema'\nimport {isEqualMarks} from '../equality'\nimport type {TypedObject, WhiteSpacePasteMode} from '../types'\nimport {isMinimalSpan} from './helpers'\n\nexport function trimWhitespace(\n  context: {schema: Schema},\n  mode: WhiteSpacePasteMode,\n  blocks: TypedObject[],\n): TypedObject[] {\n  const trimmedBlocks: TypedObject[] = []\n  let consecutiveEmptyCount = 0\n\n  for (const block of blocks) {\n    const trimmedBlock = isTextBlock(context, block)\n      ? trimTextBlockWhitespace(block)\n      : block\n\n    if (mode === 'preserve') {\n      trimmedBlocks.push(trimmedBlock)\n\n      continue\n    }\n\n    if (mode === 'remove') {\n      if (isEmptyTextBlock(context, trimmedBlock)) {\n        continue\n      }\n\n      trimmedBlocks.push(trimmedBlock)\n\n      continue\n    }\n\n    if (mode === 'normalize') {\n      if (isEmptyTextBlock(context, trimmedBlock)) {\n        consecutiveEmptyCount++\n\n        if (consecutiveEmptyCount === 1) {\n          trimmedBlocks.push(trimmedBlock)\n        }\n\n        continue\n      }\n\n      trimmedBlocks.push(trimmedBlock)\n\n      consecutiveEmptyCount = 0\n    }\n  }\n\n  return trimmedBlocks\n}\n\nfunction isEmptyTextBlock(\n  context: {schema: Schema},\n  block: TypedObject,\n): boolean {\n  if (!isTextBlock(context, block)) {\n    return false\n  }\n\n  if (\n    block.children.some(\n      (child) => !isSpan(context, child) || child.text.trim() !== '',\n    )\n  ) {\n    return false\n  }\n\n  return true\n}\n\nfunction trimTextBlockWhitespace(\n  block: PortableTextTextBlock,\n): PortableTextTextBlock {\n  let index = 0\n\n  for (const child of block.children) {\n    if (!isMinimalSpan(child)) {\n      index++\n      continue\n    }\n\n    const nextChild = nextSpan(block, index)\n    const prevChild = prevSpan(block, index)\n\n    if (index === 0) {\n      child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n    }\n\n    if (index === block.children.length - 1) {\n      child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n    }\n\n    if (\n      /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) &&\n      nextChild &&\n      isMinimalSpan(nextChild) &&\n      /\\s/.test(nextChild.text.slice(0, 1))\n    ) {\n      child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n    }\n\n    if (\n      /\\s/.test(child.text.slice(0, 1)) &&\n      prevChild &&\n      isMinimalSpan(prevChild) &&\n      /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1)))\n    ) {\n      child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n    }\n\n    if (!child.text) {\n      block.children.splice(index, 1)\n    }\n\n    if (\n      prevChild &&\n      Array.isArray(prevChild.marks) &&\n      isEqualMarks(prevChild.marks, child.marks) &&\n      isWhiteSpaceChar(child.text)\n    ) {\n      prevChild.text += ' '\n      block.children.splice(index, 1)\n    } else if (\n      nextChild &&\n      Array.isArray(nextChild.marks) &&\n      isEqualMarks(nextChild.marks, child.marks) &&\n      isWhiteSpaceChar(child.text)\n    ) {\n      nextChild.text = ` ${nextChild.text}`\n      block.children.splice(index, 1)\n    }\n\n    index++\n  }\n\n  return block\n}\n\nfunction nextSpan(block: PortableTextTextBlock, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: PortableTextTextBlock, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n} from '@portabletext/schema'\nimport {vercelStegaClean} from '@vercel/stega'\nimport type {\n  ArbitraryTypedObject,\n  DeserializerRule,\n  HtmlDeserializerOptions,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {keyGenerator} from '../util/randomKey'\nimport {resolveJsType} from '../util/resolveJsType'\nimport {flattenNestedBlocks} from './flatten-nested-blocks'\nimport {\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  isMinimalBlock,\n  isMinimalSpan,\n  isNodeList,\n  isPlaceholderAnnotation,\n  isPlaceholderDecorator,\n  tagName,\n} from './helpers'\nimport {preprocessors} from './preprocessors'\nimport {createRules} from './rules'\nimport {trimWhitespace} from './trim-whitespace'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  keyGenerator: () => string\n  schema: Schema\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  whitespaceMode: 'preserve' | 'remove' | 'normalize'\n  _markDefs: PortableTextObject[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(schema: Schema, options: HtmlDeserializerOptions = {}) {\n    const {rules = [], unstable_whitespaceOnPasteMode = 'preserve'} = options\n    const standardRules = createRules(schema, {\n      keyGenerator: options.keyGenerator,\n      matchers: options.matchers,\n    })\n    this.schema = schema\n    this.keyGenerator = options.keyGenerator ?? keyGenerator\n    this.rules = [...rules, ...standardRules]\n    this.whitespaceMode = unstable_whitespaceOnPasteMode\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.parseHtml = (html) => {\n      const cleanHTML = vercelStegaClean(html)\n      const doc = parseHtml(cleanHTML)\n\n      for (const processor of preprocessors) {\n        processor(cleanHTML, doc)\n      }\n\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n\n    const blocks = trimWhitespace(\n      {schema: this.schema},\n      this.whitespaceMode,\n      flattenNestedBlocks(\n        {schema: this.schema},\n        ensureRootIsBlocks(\n          this.schema,\n          this.deserializeElements(children) as Array<ArbitraryTypedObject>,\n        ),\n      ),\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block) => isTextBlock({schema: this.schema}, block))\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return block.children\n                .flatMap((child) => child.marks || [])\n                .includes(def._key)\n            }),\n          )\n        })\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = this.schema.block.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (\n      elements: Node | Node[] | NodeList,\n    ): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node: TypedObject | Array<TypedObject> | undefined\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (\n        type !== 'array' &&\n        type !== 'object' &&\n        type !== 'null' &&\n        type !== 'undefined'\n      ) {\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`,\n        )\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        'listItem' in ret\n      ) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        ret.style === 'blockquote'\n      ) {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (\n    annotation: PlaceholderAnnotation,\n  ): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqualMarks} from '../equality'\nimport type {TypedObject} from '../types'\nimport {keyGenerator} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n\n  /**\n   * Custom key generator function\n   */\n  keyGenerator?: () => string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {},\n): Omit<\n  TypedObject | PortableTextTextBlock<TypedObject | PortableTextSpan>,\n  '_key'\n> & {\n  _key: string\n} {\n  const schema: Schema = {\n    block: {\n      name: options.blockTypeName || 'block',\n    },\n    span: {\n      name: 'span',\n    },\n    styles: [],\n    lists: [],\n    decorators: [],\n    annotations: [],\n    blockObjects: [],\n    inlineObjects: [],\n  }\n\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node\n      ? (node as TypedObject & {_key: string})\n      : {\n          ...node,\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        }\n  }\n\n  const block: Omit<\n    PortableTextTextBlock<TypedObject | PortableTextSpan>,\n    'style'\n  > = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce(\n      (acc, child) => {\n        const previousChild = acc[acc.length - 1]\n        if (\n          previousChild &&\n          isSpan({schema}, child) &&\n          isSpan({schema}, previousChild) &&\n          isEqualMarks(previousChild.marks, child.marks)\n        ) {\n          if (\n            lastChild &&\n            lastChild === child &&\n            child.text === '' &&\n            block.children.length > 1\n          ) {\n            return acc\n          }\n\n          previousChild.text += child.text\n          return acc\n        }\n        acc.push(child)\n        return acc\n      },\n      [] as (TypedObject | PortableTextSpan)[],\n    )\n    .map((child) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = options.keyGenerator\n        ? options.keyGenerator()\n        : keyGenerator()\n\n      if (isSpan({schema}, child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs?.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = (block.markDefs || []).filter((markDef) =>\n    usedMarkDefs.includes(markDef._key),\n  )\n\n  return block\n}\n","import {sanitySchemaToPortableTextSchema} from '@portabletext/sanity-bridge'\nimport type {Schema} from '@portabletext/schema'\nimport type {ArraySchemaType} from '@sanity/types'\nimport HtmlDeserializer from './HtmlDeserializer'\nimport type {HtmlDeserializerOptions, TypedObject} from './types'\nimport {normalizeBlock} from './util/normalizeBlock'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param schemaType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  schemaType: ArraySchemaType | Schema,\n  options: HtmlDeserializerOptions = {},\n) {\n  const schema = isSanitySchema(schemaType)\n    ? sanitySchemaToPortableTextSchema(schemaType)\n    : schemaType\n\n  const deserializer = new HtmlDeserializer(schema, options)\n  return deserializer\n    .deserialize(html)\n    .map((block) => normalizeBlock(block, {keyGenerator: options.keyGenerator}))\n}\n\nexport type {ImageSchemaMatcher, SchemaMatchers} from './schema-matchers'\nexport type {ArbitraryTypedObject, DeserializerRule, HtmlParser} from './types'\nexport type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@portabletext/schema'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\nexport {randomKey} from './util/randomKey'\nexport {normalizeBlock}\nexport type {HtmlDeserializerOptions, TypedObject}\n\nfunction isSanitySchema(\n  schema: ArraySchemaType | Schema,\n): schema is ArraySchemaType {\n  return schema.hasOwnProperty('jsonType')\n}\n"],"names":["_","span","isEmphasis","isStrong","isUnderline","getListItemStyle","getListItemLevel","blocks","image","vercelStegaClean"],"mappings":"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","debugId":null}}]
}